<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>如何用GVM管理Go项目</title>
      <link href="//blog/%E5%A6%82%E4%BD%95%E7%94%A8GVM%E7%AE%A1%E7%90%86Go%E9%A1%B9%E7%9B%AE.html"/>
      <url>//blog/%E5%A6%82%E4%BD%95%E7%94%A8GVM%E7%AE%A1%E7%90%86Go%E9%A1%B9%E7%9B%AE.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用 Go 版本管理器管理多个版本的 Go 语言环境及其模块</p></blockquote><p><img src="https://cdn.learnku.com/uploads/images/201910/18/36517/ZDHqtzEHMw.png!large" alt="如何用 GVM 管理 Go 项目"></p><p>Go 语言版本管理器（<a href="https://github.com/moovweb/gvm" target="_blank" rel="noopener">GVM</a>）是管理 Go 语言环境的开源工具。GVM 「pkgsets」 支持安装多个版本的 Go 并管理每个项目的模块。它最初由 <a href="https://github.com/jbussdieker" target="_blank" rel="noopener">Josh Bussdieker</a> 开发，GVM（像它的对手 Ruby RVM 一样）允许你为每个项目或一组项目创建一个开发环境，分离不同的 Go 版本和包依赖关系，来提供更大的灵活性，以防不同版本造成的问题。</p><p>有几种管理 Go 包的方式，包括 Go 1.11 内置于 Go 中的 Modules。我发现GVM简单而直观，即使我不使用它来管理包，我仍然会使用它来管理不同的 Go 版本。</p><a id="more"></a><h2 id="安装-GVM"><a href="#安装-GVM" class="headerlink" title="安装 GVM"></a>安装 GVM</h2><p>安装 GVM 很简单。<a href="https://github.com/moovweb/gvm#installation" target="_blank" rel="noopener">GVM库</a>安装文档指导您下载安装脚本并将其导入 Bash。</p><p><code>bash &lt; &lt;(curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer)</code></p><p>尽管越来越多的人采用这种安装方法，但最好还是在安装之前先看看安装程序在做什么。以 GVM 为例，安装脚本执行过程：</p><ol><li>检查相关依赖</li><li>克隆 GVM 库</li><li>使用 shell 脚本:<ul><li>安装 Go 语言</li><li>管理 GOPATH 环境变量</li><li>在 bashrc 、zshrc 或配置文件中添加一行内容</li></ul></li></ol><p>如果您想再次检查它在做什么，您可以克隆库并检查 shel l脚本，然后运行 <code>./binscripts/gvm-installer</code> 使用本地脚本进行设置。</p><p><em>注意:</em> 由于 GVM 可用于下载和编译新的 Go 版本，因此会有一些预期的依赖项，如 Make，Git 和 Curl。你可以在<a href="https://github.com/moovweb/gvm/blob/master/README.md" target="_blank" rel="noopener">GVM 的 README</a> 中找到完整的发行版列表。</p><h2 id="使用-GVM-安装和管理-Go-版本"><a href="#使用-GVM-安装和管理-Go-版本" class="headerlink" title="使用 GVM 安装和管理 Go 版本"></a>使用 GVM 安装和管理 Go 版本</h2><p>一旦安装了 GVM，您就可以开始使用它来安装和管理不同版本的 Go。<code>gvm listall</code> 命令显示了可以下载和编译的可用的 Go 版本：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[chris@marvin ]$ gvm listall</span><br><span class="line">$ gvm listall</span><br><span class="line"></span><br><span class="line">gvm gos (available)</span><br><span class="line"></span><br><span class="line">   go1</span><br><span class="line">   go1<span class="number">.0</span><span class="number">.1</span></span><br><span class="line">   go1<span class="number">.0</span><span class="number">.2</span></span><br><span class="line">   go1<span class="number">.0</span><span class="number">.3</span></span><br><span class="line"></span><br><span class="line">&lt;输出截断&gt;</span><br></pre></td></tr></table></figure><p>安装特定的 Go 版本就想 <code>gvm install &lt;version&gt;</code> 一样简单，其中 <code>&lt;version&gt;</code> 是 <code>gvm install</code> 命令返回的版本之一。</p><p>假设您正在处理一个使用 Go 1.12.8 版本的项目。你可以使用 <code>gvm install go1.12.8</code> 命令来安装这个版本:</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[chris@marvin]$ gvm install go1<span class="number">.12</span><span class="number">.8</span></span><br><span class="line">Installing go1<span class="number">.12</span><span class="number">.8</span>...</span><br><span class="line"> * Compiling...</span><br><span class="line">go1<span class="number">.12</span><span class="number">.8</span> successfully installed!</span><br></pre></td></tr></table></figure><p>输入 <code>gvm list</code>，你会看到 Go 1.12.8 版本与系统 Go 版本（使用操作系统的软件包管理器打包的版本）同时存在：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[chris@marvin]$ gvm list</span><br><span class="line">gvm gos (installed)</span><br><span class="line">   <span class="symbol">go1</span>.<span class="number">12.8</span></span><br><span class="line">=&gt; system</span><br></pre></td></tr></table></figure><p>GVM 仍然再使用系统的 Go 版本，通过它旁边的 <strong>=&gt;</strong> 符号来表示。你可以使用 <code>gvm use</code> 命令来切换到新安装的 go1.12.8版本：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[chris@marvin]$ gvm <span class="keyword">use</span> go1<span class="number">.12</span><span class="number">.8</span></span><br><span class="line"><span class="keyword">Now</span> <span class="keyword">using</span> <span class="keyword">version</span> go1<span class="number">.12</span><span class="number">.8</span></span><br><span class="line">[chris@marvin]$ <span class="keyword">go</span> <span class="keyword">version</span></span><br><span class="line"><span class="keyword">go</span> <span class="keyword">version</span> go1<span class="number">.12</span><span class="number">.8</span> linux/amd64</span><br></pre></td></tr></table></figure><p>GVM使管理已安装的Go版本变得极其简单，但它不止如此！</p><h2 id="使用-GVM-pkgset"><a href="#使用-GVM-pkgset" class="headerlink" title="使用 GVM pkgset"></a>使用 GVM pkgset</h2><p>在开箱即用的情况下，Go 以一种出色而又令人沮丧的方式管理包和模块。默认情况下，如果你 <code>go get</code> 获取一个包，它会被下载到  <code>$GOPATH</code> 目录中的 <code>src</code> 和 <code>pkg</code> 目录下；然后你可以使用 <code>import</code> 将其引入到你的 Go 程序中。这使得获取包变得很容易，特别是对于没有特权的用户，不需要 <code>sudo</code> 或 root 特权(很像 Python 中的<code>pip install --user</code>)。然而，在不同的项目中管理相同包的不同版本是困难的。</p><p>有许多方法可以尝试修复或缓解这个问题，包括实验性的 Go Modules (在 Go v1.11 版本中增加了初步支持)和 <a href="https://golang.github.io/dep/" target="_blank" rel="noopener">Go dep</a>(一个「官方实验」，被正在被 Go Modules 所替代)。在我发现GVM之前，为了确保隔离，我会在自己的Docker容器中构建和测试Go项目。</p><p>GVM 通过使用「pkgsets」将项目的新目录附加到 Go 安装版本的默认 <code>$GOPATH</code>，很像在 Unix/Linux 系统上工作的<code>$PATH</code>，很好地完成了项目之间包的管理和隔离。</p><p>很容易想象这是如何运行的。首先，安装新版本的Go 1.12.9：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[chris@marvin]$ echo $GOPATH</span><br><span class="line">/home/chris/.gvm/pkgsets/go1<span class="meta">.12</span><span class="meta">.8</span>/<span class="meta">global</span></span><br><span class="line">[chris@marvin]$ gvm install go1<span class="meta">.12</span><span class="meta">.9</span></span><br><span class="line">Installing go1<span class="meta">.12</span><span class="meta">.9</span>...</span><br><span class="line"> * Compiling...</span><br><span class="line">go1<span class="meta">.12</span><span class="meta">.9</span> successfully installed</span><br><span class="line">[chris@marvin]$ gvm use go1<span class="meta">.12</span><span class="meta">.9</span></span><br><span class="line">Now using version go1<span class="meta">.12</span><span class="meta">.9</span></span><br></pre></td></tr></table></figure><p>当 GVM 被告知使用一个新版本时，它将会更换一个新的 <code>$GOPATH</code>，<strong>gloabl</strong> pkgset 将默认使用该版本：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[chris@marvin]$ echo $GOPATH</span><br><span class="line">/home/chris/.gvm/pkgsets/<span class="symbol">go1</span>.<span class="number">12.9</span>/global</span><br><span class="line">[chris@marvin]$ gvm pkgset list</span><br><span class="line">gvm go package sets (<span class="symbol">go1</span>.<span class="number">12.9</span>)</span><br><span class="line">=&gt;  global</span><br></pre></td></tr></table></figure><p>尽管默认情况下没有安装额外的包，但是 global pkgset 中的包对于使用这个特定版本 Go 的任何项目都是可用的。</p><p>现在，假设您正在启动一个新项目，它需要一个特定的包。首先，使用 GVM 创建一个名为 <code>introToGvm</code> 的新的pkgset：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[chris@marvin]$ gvm pkgset create introToGvm</span><br><span class="line">[chris@marvin]$ gvm pkgset use introToGvm</span><br><span class="line"><span class="built_in">Now</span> using version <span class="symbol">go1</span>.<span class="number">12.9</span>@introToGvm</span><br><span class="line">[chris@marvin]$ gvm pkgset list</span><br><span class="line">gvm go package sets (<span class="symbol">go1</span>.<span class="number">12.9</span>)</span><br><span class="line">    global</span><br><span class="line">=&gt;  introToGvm</span><br></pre></td></tr></table></figure><p>如上所述，pkgset 的一个新目录被添加到 <code>$GOPATH</code>：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[chris<span class="meta">@marvin</span>]$ echo $GOPATH</span><br><span class="line"><span class="regexp">/home/</span>chris<span class="regexp">/.gvm/</span>pkgsets<span class="regexp">/go1.12.9/</span><span class="string">introToGvm:</span><span class="regexp">/home/</span>chris<span class="regexp">/.gvm/</span>pkgsets<span class="regexp">/go1.12.9/</span>global</span><br></pre></td></tr></table></figure><p>将目录更改为预先设置的 <code>introToGvm</code> 路径，并检查目录结构，然后利用这个机会体验一下 <code>awk</code> 和 <code>bash</code> 的乐趣:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[chris<span class="variable">@marvin</span>]<span class="variable">$ </span>cd <span class="variable">$(</span> awk -F<span class="string">':'</span> <span class="string">'&#123;print $1&#125;'</span> &lt;&lt;&lt; <span class="variable">$GOPATH</span> )</span><br><span class="line">[chris<span class="variable">@marvin</span>]<span class="variable">$ </span>pwd</span><br><span class="line">/home/chris/.gvm/pkgsets/go1.<span class="number">12.9</span>/introToGvm</span><br><span class="line">[chris<span class="variable">@marvin</span>]<span class="variable">$ </span>ls</span><br><span class="line">overlay  pkg  src</span><br></pre></td></tr></table></figure><p>注意，新目录看起来很像普通的 <code>$GOPATH</code>。新的 Go 包可以使用与 Go 相同的 <code>Go get</code> 下载命令，且被添加到 pkgset中。</p><p>例如，使用以下代码获得 <code>gorilla/mux</code> 包，然后检查 pkgset：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[chris@marvin]$ go get github.com/gorilla/mux</span><br><span class="line">[chris@marvin]$ tree</span><br><span class="line">[chris@marvin introToGvm ]$ tree</span><br><span class="line">.</span><br><span class="line">├── overlay</span><br><span class="line">│   ├── bin</span><br><span class="line">│   └── lib</span><br><span class="line">│       └── pkgconfig</span><br><span class="line">├── pkg</span><br><span class="line">│   └── linux_amd64</span><br><span class="line">│       └── github.com</span><br><span class="line">│           └── gorilla</span><br><span class="line">│               └── mux.a</span><br><span class="line">src/</span><br><span class="line">└── github.com</span><br><span class="line">    └── gorilla</span><br><span class="line">        └── mux</span><br><span class="line">            ├── AUTHORS</span><br><span class="line">            ├── bench_test.go</span><br><span class="line">            ├── context.go</span><br><span class="line">            ├── context_test.go</span><br><span class="line">            ├── doc.go</span><br><span class="line">            ├── example_authentication_middleware_test.go</span><br><span class="line">            ├── example_cors_method_middleware_test.go</span><br><span class="line">            ├── example_route_test.go</span><br><span class="line">            ├── go.mod</span><br><span class="line">            ├── LICENSE</span><br><span class="line">            ├── middleware.go</span><br><span class="line">            ├── middleware_test.go</span><br><span class="line">            ├── mux.go</span><br><span class="line">            ├── mux_test.go</span><br><span class="line">            ├── old_test.go</span><br><span class="line">            ├── README.md</span><br><span class="line">            ├── regexp.go</span><br><span class="line">            ├── route.go</span><br><span class="line">            └── test_helpers.go</span><br></pre></td></tr></table></figure><p>如您所见，<code>gorilla/mux</code> 按照预期添加到了 pkgset  的 <code>$GOPATH</code> 目录，现在它可以与使用该 pkgset 的项目一起使用了。</p><h2 id="GVM-让-Go-管理变得轻而易举"><a href="#GVM-让-Go-管理变得轻而易举" class="headerlink" title="GVM 让 Go 管理变得轻而易举"></a>GVM 让 Go 管理变得轻而易举</h2><p>GVM 是以一种直观的、非侵入性的方式来管理 Go 版本和包的。它可以单独使用，也可以使用 GVM 的 Go 版本管理功能与其他 Go 模块管理技术结合使用。通过 Go 版本和包依赖关系隔离项目使开发更容易，并减少了管理版本冲突的复杂性，而GVM使这变得轻而易举。</p><blockquote><p>本文译自 <a href="https://opensource.com/article/19/10/go-introduction-gvm" target="_blank" rel="noopener">opensource</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>php原理之对象的属性</title>
      <link href="//blog/php%E5%8E%9F%E7%90%86%E4%B9%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7.html"/>
      <url>//blog/php%E5%8E%9F%E7%90%86%E4%B9%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7.html</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>之前用easyWechat时获取的用户信息是protected的对象,使用了<code>\0*\0</code>来获取到受保护的对象中的数据,最近在学习php底层的知识,本文讲述了为什么<code>\0*\0</code>能获取到受保护的数据</p></blockquote><h2 id="对象的结构"><a href="#对象的结构" class="headerlink" title="对象的结构"></a>对象的结构</h2><p>在php中,一个对象,还是以一个zval做为载体的</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="class"><span class="keyword">union</span> <span class="title">_zvalue_value</span> &#123;</span></span><br><span class="line">    long lval;</span><br><span class="line">    double dval;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        char *val;</span><br><span class="line">        int len;</span><br><span class="line">    &#125; str;</span><br><span class="line">    HashTable *ht;</span><br><span class="line">    zend_object_value obj;</span><br><span class="line">&#125; zvalue_value;</span><br></pre></td></tr></table></figure><a id="more"></a><p>如果,一个zval是对象,那么zvalue_value中的对象,就指向一个zend_object_value的实例。一个zend_object_value包含两个成员,一个是标识符(整形序号),表明了当前对象存储在全局对象列表的位置,另外还有一个zend_object_handlers指针,指向当前对象所属类的handlers(标准操作集合).<br>真正的对象实体,zend_object中,保存了如下的关键信息入口:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="selector-class">.ce</span>,zend_class_entry 类入口</span><br><span class="line"><span class="number">2</span><span class="selector-class">.properties</span>,hashTable普通属性集</span><br></pre></td></tr></table></figure><h2 id="对象的属性"><a href="#对象的属性" class="headerlink" title="对象的属性"></a>对象的属性</h2><p>如上所述,普通属性是一个hashTable,在PHP5以后,引入了访问权限控制,而访问权限属性,是通过属性名进行区分的(为此Zend引入了zend_mangle_property_name)</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>public 属性名</span><br><span class="line"><span class="number">2.</span>private \<span class="number">0</span>类名\<span class="number">0</span>属性名</span><br><span class="line"><span class="number">3.</span>protected \<span class="number">0</span>*\<span class="number">0</span>属性名</span><br></pre></td></tr></table></figure><p>PHP通过这种方式,实现了对属性访问权限的标识,所以我们如果想要访问对象的私有/保护属性可以:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $_name1 = <span class="string">"private"</span>;</span><br><span class="line">    <span class="keyword">protected</span> $_name2 = <span class="string">"protected"</span>;</span><br><span class="line">&#125;</span><br><span class="line">$test = <span class="keyword">new</span> Test();</span><br><span class="line">$arr = (<span class="keyword">array</span>)$test;</span><br><span class="line">var_dump($arr[<span class="string">"\0Test\0_name1"</span>]);</span><br><span class="line">var_dump($arr[<span class="string">"\0*\0_name2"</span>]);</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">string(<span class="number">7</span>) <span class="string">"private"</span></span><br><span class="line">string(<span class="number">9</span>) <span class="string">"protected"</span></span><br></pre></td></tr></table></figure><p><code>参考自鸟哥博客</code><a href="http://www.laruence.com" target="_blank" rel="noopener">http://www.laruence.com</a></p>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决mac command not found</title>
      <link href="//blog/%E8%A7%A3%E5%86%B3mac%20command%20not%20found.html"/>
      <url>//blog/%E8%A7%A3%E5%86%B3mac%20command%20not%20found.html</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>最近在配置mac的环境变量后,系统的所有命令都失效了,提示mac command not found,在此记录解决方法</p></blockquote><h2 id="1-先让命令暂时可用"><a href="#1-先让命令暂时可用" class="headerlink" title="1.先让命令暂时可用"></a>1.先让命令暂时可用</h2><p>命令如下</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=<span class="regexp">/usr/bin</span><span class="symbol">:/usr/sbin</span><span class="symbol">:/bin</span><span class="symbol">:/sbin</span><span class="symbol">:/usr/X11R6/bin</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>命令执行后不要关闭终端或者cd /usr/bin 下执行vi命令否则会再次失效  </p><h2 id="2-检查bash-profile文件"><a href="#2-检查bash-profile文件" class="headerlink" title="2.检查bash_profile文件"></a>2.检查bash_profile文件</h2><p>很有可能是你的PATH 环境变量设置错误，比如 <code>$PATH</code>漏了，我这里的错误是添加环境变量的时候没有使用<code>&quot;&quot;</code>双引号引起来，还有<code>=</code>等号后面有空格，不知道等号后面有空格会不会影响，加上双引号，去掉空格就可以了<code>PATH=$PATH:$PATH1</code> 可以写成这样的格式：<code>export PATH=/usr/local/msyql/bin:$PATH</code></p><h2 id="3-保存bash-profile文件"><a href="#3-保存bash-profile文件" class="headerlink" title="3.保存bash_profile文件"></a>3.保存bash_profile文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
