<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>深入理解golang之http server</title>
      <link href="//blog/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3golang%E4%B9%8Bhttp%20server.html"/>
      <url>//blog/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3golang%E4%B9%8Bhttp%20server.html</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>对于 Golang 来说，实现一个简单的 <code>http server</code> 非常容易，只需要短短几行代码。同时有了协程的加持，Go 实现的 <code>http server</code> 能够取得非常优秀的性能。这篇文章将会对 go 标准库 <code>net/http</code> 实现 http 服务的原理进行较为深入的探究，以此来学习了解网络编程的常见范式以及设计思路。</p><a id="more"></a><h3 id="HTTP服务"><a href="#HTTP服务" class="headerlink" title="HTTP服务"></a>HTTP服务</h3><p>基于 HTTP 构建的网络应用包括两个端，即客户端( <code>Client</code> )和服务端( <code>Server</code> )。两个端的交互行为包括从客户端发出 <code>request</code>、服务端接受 <code>request</code> 进行处理并返回 <code>response</code> 以及客户端处理 <code>response</code>。所以http服务器的工作就在于如何接受来自客户端的 <code>request</code>，并向客户端返回 <code>response</code>。</p><p>典型的 http 服务端的处理流程可以用下图表示：</p><p><img src="https://cdn.learnku.com/uploads/images/202001/13/36517/54v6mIm1nI.webp!large" alt></p><p>服务器在接收到请求时，首先会进入路由( <code>router</code> )，这是一个 <code>Multiplexer</code>，路由的工作在于为这个 <code>request</code> 找到对应的处理器( <code>handler</code> )，处理器对 <code>request</code> 进行处理，并构建 <code>response</code>。Golang 实现的 <code>http server</code> 同样遵循这样的处理流程。</p><p>我们先看看 Golang 如何实现一个简单的 <code>http server</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indexHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Fprintf(w, <span class="string">"hello world"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, indexHandler)</span><br><span class="line">http.ListenAndServe(<span class="string">":8000"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码之后，在浏览器中打开 <code>localhost:8000</code> 就可以看到 <code>hello world</code>。这段代码先利用 <code>http.HandleFunc</code> 在根路由 <code>/</code> 上注册了一个 <code>indexHandler</code>, 然后利用 <code>http.ListenAndServe</code> 开启监听。当有请求过来时，则根据路由执行对应的 <code>handler</code> 函数。</p><p>我们再来看一下另外一种常见的 <code>http server</code> 实现方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> indexHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">content <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ih *indexHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Fprintf(w, ih.content)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.Handle(<span class="string">"/"</span>, &amp;indexHandler&#123;content: <span class="string">"hello world!"</span>&#125;)</span><br><span class="line">http.ListenAndServe(<span class="string">":8001"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go实现的<code>http</code>服务步骤非常简单，首先注册路由，然后创建服务并开启监听即可。下文我们将从注册路由、开启服务、处理请求这几个步骤了解Golang如何实现<code>http</code>服务。</p><h3 id="注册路由"><a href="#注册路由" class="headerlink" title="注册路由"></a>注册路由</h3><p><code>http.HandleFunc</code> 和 <code>http.Handle</code> 都是用于注册路由，可以发现两者的区别在于第二个参数，前者是一个具有 <code>func(w http.ResponseWriter, r *http.Requests)</code> 签名的函数，而后者是一个结构体，该结构体实现了 <code>func(w http.ResponseWriter, r *http.Requests)</code> 签名的方法。<br><code>http.HandleFunc</code> 和 <code>http.Handle</code> 的源码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HandleFunc registers the handler function for the given pattern.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"http: nil handler"</span>)</span><br><span class="line">&#125;</span><br><span class="line">mux.Handle(pattern, HandlerFunc(handler))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handle</span><span class="params">(pattern <span class="keyword">string</span>, handler Handler)</span></span> &#123;</span><br><span class="line">DefaultServeMux.Handle(pattern, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这两个函数最终都由 <code>DefaultServeMux</code> 调用 <code>Handle</code> 方法来完成路由的注册。<br>这里我们遇到两种类型的对象：<code>ServeMux</code> 和 <code>Handler</code>，我们先说 <code>Handler</code>。</p><h5 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h5><p><code>Handler</code> 是一个接口：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Handler<span class="built_in"> interface </span>&#123;</span><br><span class="line">ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Handler</code> 接口中声明了名为 <code>ServeHTTP</code> 的函数签名，也就是说任何结构只要实现了这个 <code>ServeHTTP</code> 方法，那么这个结构体就是一个 <code>Handler</code> 对象。其实 go 的 <code>http</code> 服务都是基于 <code>Handler</code> 进行处理，而 <code>Handler</code> 对象的 <code>ServeHTTP</code> 方法也正是用以处理 <code>request</code> 并构建 <code>response</code> 的核心逻辑所在。</p><p>回到上面的 <code>HandleFunc</code> 函数，注意一下这行代码：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mux.Handle(pattern, HandlerFunc(<span class="keyword">handler</span>))</span><br></pre></td></tr></table></figure><p>可能有人认为 <code>HandlerFunc</code> 是一个函数，包装了传入的 <code>handler</code> 函数，返回了一个 <code>Handler</code> 对象。然而这里 <code>HandlerFunc</code> 实际上是将 <code>handler</code> 函数做了一个<strong>类型转换</strong>，看一下 <code>HandlerFunc</code> 的定义：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br><span class="line"></span><br><span class="line">// ServeHTTP calls f(w, r).</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f HandlerFunc)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span> &#123;</span></span><br><span class="line">f(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>HandlerFunc</code> 是一个类型，只不过表示的是一个具有 <code>func(ResponseWriter, *Request)</code> 签名的函数类型，并且这种类型实现了 <code>ServeHTTP</code> 方法（在 <code>ServeHTTP</code> 方法中又调用了自身），也就是说这个类型的函数其实就是一个 <code>Handler</code> 类型的对象。利用这种类型转换，我们可以将一个 <code>handler</code> 函数转换为一个<br><code>Handler</code> 对象，而不需要定义一个结构体，再让这个结构实现 <code>ServeHTTP</code> 方法。读者可以体会一下这种技巧。</p><h5 id="ServeMux"><a href="#ServeMux" class="headerlink" title="ServeMux"></a>ServeMux</h5><p>Golang中的路由（即 <code>Multiplexer</code> ）基于 <code>ServeMux</code> 结构，先看一下 <code>ServeMux</code> 的定义：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> ServeMux <span class="keyword">struct</span> &#123;</span><br><span class="line">mu    sync.RWMutex</span><br><span class="line">m     map[<span class="keyword">string</span>]muxEntry</span><br><span class="line">es    []muxEntry <span class="comment">// slice of entries sorted from longest to shortest.</span></span><br><span class="line">hosts <span class="keyword">bool</span>       <span class="comment">// whether any patterns contain hostnames</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> muxEntry <span class="keyword">struct</span> &#123;</span><br><span class="line">h       http.Handler</span><br><span class="line">pattern <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里重点关注 <code>ServeMux</code> 中的字段 <code>m</code>，这是一个 <code>map</code>，<code>key</code> 是路由表达式，<code>value</code> 是一个 <code>muxEntry</code> 结构， <code>muxEntry</code> 结构体存储了对应的路由表达式和 <code>handler</code>。</p><p>值得注意的是，<code>ServeMux</code> 也实现了 <code>ServeHTTP</code> 方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> r.RequestURI == <span class="string">"*"</span> &#123;</span><br><span class="line"><span class="keyword">if</span> r.ProtoAtLeast(<span class="number">1</span>, <span class="number">1</span>) &#123;</span><br><span class="line">w.Header().Set(<span class="string">"Connection"</span>, <span class="string">"close"</span>)</span><br><span class="line">&#125;</span><br><span class="line">w.WriteHeader(StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">h, _ := mux.Handler(r)</span><br><span class="line">h.ServeHTTP(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说 <code>ServeMux</code> 结构体也是 <code>Handler</code> 对象，只不过 <code>ServeMux</code> 的 <code>ServeHTTP</code> 方法不是用来处理具体的 <code>request</code> 和构建 <code>response</code>，而是用来确定路由注册的 <code>handler</code>。</p><h5 id="注册路由-1"><a href="#注册路由-1" class="headerlink" title="注册路由"></a>注册路由</h5><p>搞明白<code>Handler</code> 和 <code>ServeMux</code> 之后，我们再回到之前的代码：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DefaultServeMux.Handle(pattern, <span class="keyword">handler</span>)</span><br></pre></td></tr></table></figure><p>这里的 <code>DefaultServeMux</code> 表示一个默认的 <code>Multiplexer</code>，当我们没有创建自定义的 <code>Multiplexer</code>，则会自动使用一个默认的 <code>Multiplexer</code>。</p><p>然后再看一下 <code>ServeMux</code> 的 <code>Handle</code> 方法具体做了什么：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">Handle</span><span class="params">(patternstring, handlerHandler)</span></span> &#123;</span><br><span class="line">mux.mu.Lock()</span><br><span class="line">defermux.mu.Unlock()</span><br><span class="line"><span class="keyword">if</span> pattern == <span class="string">""</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"http:invalidpattern"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"http:nilhandler"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> _, exist := mux.m[pattern]; exist &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"http: multiple registrations for "</span> + pattern)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> mux.m == <span class="literal">nil</span> &#123;</span><br><span class="line">mux.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//利用当前的路由和handler创建muxEntry对象</span></span><br><span class="line">e := muxEntry&#123;h: handler, pattern: pattern&#125;</span><br><span class="line"><span class="comment">//向ServeMux的map[string]muxEntry增加新的路由匹配规则</span></span><br><span class="line">mux.m[pattern] = e</span><br><span class="line"><span class="comment">//如果路由表达式以'/'结尾，则将对应的muxEntry对象加入到[]muxEntry中，按照路由表达式长度排序</span></span><br><span class="line"><span class="keyword">if</span> pattern[<span class="built_in">len</span>(pattern)<span class="number">-1</span>] == <span class="string">'/'</span> &#123;</span><br><span class="line">mux.es = appendSorted(mux.es, e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> pattern[<span class="number">0</span>] != <span class="string">'/'</span> &#123;</span><br><span class="line">mux.hosts = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Handle</code> 方法主要做了两件事情：一个就是向 <code>ServeMux</code> 的 <code>map[string]muxEntry</code> 增加给定的路由匹配规则；然后如果路由表达式以 <code>&#39;/&#39;</code> 结尾，则将对应的 <code>muxEntry</code> 对象加入到 <code>[]muxEntry</code> 中，按照路由表达式长度排序。前者很好理解，但后者可能不太容易看出来有什么作用，这个问题后面再作分析。</p><h5 id="自定义-ServeMux"><a href="#自定义-ServeMux" class="headerlink" title="自定义 ServeMux"></a>自定义 ServeMux</h5><p>我们也可以创建自定义的 <code>ServeMux</code> 取代默认的 <code>DefaultServeMux</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">"fmt"</span><br><span class="line">"net/http"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func indexHandler(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">fmt.Fprintf(w, "hello  world")</span><br><span class="line">&#125;</span><br><span class="line">func htmlHandler(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">w.Header().Set("Content-Type", "text/html")</span><br><span class="line">html := `<span class="meta">&lt;!doctype  html&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">META</span>  <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span>  <span class="attr">content</span>=<span class="string">"text/html"</span>  <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>  <span class="attr">lang</span>=<span class="string">"zhCN"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Golang<span class="tag">&lt;/<span class="name">title</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span>  <span class="attr">name</span>=<span class="string">"viewport"</span>  <span class="attr">content</span>=<span class="string">"width=device-width,  initial-scale=1.0,  maximum-scale=1.0,  user-scalable=0;"</span>  /&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>        </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>  <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span>Welcome!<span class="tag">&lt;/<span class="name">div</span>&gt;</span>       </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span>`</span><br><span class="line">fmt.Fprintf(w, html)</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">mux := http.NewServeMux()</span><br><span class="line">mux.Handle("/", http.HandlerFunc(indexHandler))</span><br><span class="line">mux.HandleFunc("/welcome", htmlHandler)</span><br><span class="line">http.ListenAndServe(":8001", mux)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>NewServeMux()</code> 可以创建一个 <code>ServeMux</code> 实例，之前提到 <code>ServeMux</code> 也实现了 <code>ServeHTTP</code> 方法，因此 <code>mux</code> 也是一个 <code>Handler</code> 对象。对于 <code>ListenAndServe()</code> 方法，如果传入的 <code>handler</code> 参数是自定义 <code>ServeMux</code> 实例 <code>mux</code>，那么 <code>Server</code> 实例接收到的路由对象将不再是 <code>DefaultServeMux</code> 而是 <code>mux</code>。</p><h3 id="开启服务"><a href="#开启服务" class="headerlink" title="开启服务"></a>开启服务</h3><p>首先从 <code>http.ListenAndServe</code> 这个方法开始：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(addr <span class="keyword">string</span>, handler Handler)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">server := &amp;Server&#123;Addr: addr, Handler: handler&#125;</span><br><span class="line"><span class="keyword">return</span> server.ListenAndServe()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">ListenAndServe</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> srv.shuttingDown() &#123;</span><br><span class="line"><span class="keyword">return</span> ErrServerClosed</span><br><span class="line">&#125;</span><br><span class="line">addr := srv.Addr</span><br><span class="line"><span class="keyword">if</span> addr == <span class="string">""</span> &#123;</span><br><span class="line">addr = <span class="string">":http"</span></span><br><span class="line">&#125;</span><br><span class="line">ln, err := net.Listen(<span class="string">"tcp"</span>, addr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> srv.Serve(tcpKeepAliveListener&#123;ln.(*net.TCPListener)&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先创建了一个 <code>Server</code> 对象，传入了地址和 <code>handler</code> 参数，然后调用 <code>Server</code> 对象 <code>ListenAndServe()</code> 方法。</p><p>看一下 <code>Server</code> 这个结构体，<code>Server</code> 结构体中字段比较多，可以先大致了解一下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">type Server struct &#123;</span><br><span class="line">Addr              string  <span class="comment">// TCP address to listen on, ":http" if empty</span></span><br><span class="line">Handler           Handler <span class="comment">// handler to invoke, http.DefaultServeMux if nil</span></span><br><span class="line">TLSConfig         *tls.Config</span><br><span class="line">ReadTimeout       <span class="selector-tag">time</span>.Duration</span><br><span class="line">ReadHeaderTimeout <span class="selector-tag">time</span>.Duration</span><br><span class="line">WriteTimeout      <span class="selector-tag">time</span>.Duration</span><br><span class="line">IdleTimeout       <span class="selector-tag">time</span>.Duration</span><br><span class="line">MaxHeaderBytes    int</span><br><span class="line">TLSNextProto      map[string]func(*Server, *tls<span class="selector-class">.Conn</span>, Handler)</span><br><span class="line">ConnState         func(net<span class="selector-class">.Conn</span>, ConnState)</span><br><span class="line">ErrorLog          *log.Logger</span><br><span class="line">disableKeepAlives int32     <span class="comment">// accessed atomically.</span></span><br><span class="line">inShutdown        int32     <span class="comment">// accessed atomically (non-zero means we're in Shutdown)</span></span><br><span class="line">nextProtoOnce     sync<span class="selector-class">.Once</span> <span class="comment">// guards setupHTTP2_* init</span></span><br><span class="line">nextProtoErr      error     <span class="comment">// result of http2.ConfigureServer if used</span></span><br><span class="line">mu                sync.Mutex</span><br><span class="line">listeners         map[*net.Listener]struct&#123;&#125;</span><br><span class="line">activeConn        map[*conn]struct&#123;&#125;</span><br><span class="line">doneChan          chan struct&#123;&#125;</span><br><span class="line">onShutdown        []func()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>Server</code> 的 <code>ListenAndServe</code> 方法中，会初始化监听地址 <code>Addr</code>，同时调用 <code>Listen</code> 方法设置监听。最后将监听的 TCP 对象传入 <code>Serve</code> 方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">Serve</span><span class="params">(l net.Listener)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">baseCtx := context.Background() <span class="comment">// base is always background, per Issue 16220</span></span><br><span class="line">ctx := context.WithValue(baseCtx, ServerContextKey, srv)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">rw, e := l.Accept() <span class="comment">// 等待新的连接建立</span></span><br><span class="line">...</span><br><span class="line">c := srv.newConn(rw)</span><br><span class="line">c.setState(c.rwc, StateNew) <span class="comment">// before Serve can return</span></span><br><span class="line"><span class="keyword">go</span> c.serve(ctx)             <span class="comment">// 创建新的协程处理请求</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里隐去了一些细节，以便了解 <code>Serve</code> 方法的主要逻辑。首先创建一个上下文对象，然后调用 <code>Listener</code> 的 <code>Accept()</code> 等待新的连接建立；一旦有新的连接建立，则调用 <code>Server</code> 的 <code>newConn()</code> 创建新的连接对象，并将连接的状态标志为 <code>StateNew</code>，然后开启一个新的 <code>goroutine</code> 处理连接请求。</p><h3 id="处理连接"><a href="#处理连接" class="headerlink" title="处理连接"></a>处理连接</h3><p>我们继续探索 <code>conn</code> 的 <code>serve()</code> 方法，这个方法同样很长，我们同样只看关键逻辑。坚持一下，马上就要看见大海了。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(<span class="built_in">c</span> *conn)</span></span> serve(ctx context.<span class="type">Context</span>) &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">w, err := <span class="built_in">c</span>.readRequest(ctx)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">c</span>.r.remain != <span class="built_in">c</span>.server.initialReadLimitSize() &#123;</span><br><span class="line"><span class="comment">// If we read any bytes off the wire, we're active.</span></span><br><span class="line"><span class="built_in">c</span>.setState(<span class="built_in">c</span>.rwc, <span class="type">StateActive</span>)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// HTTP cannot have multiple simultaneous active requests.[*]</span></span><br><span class="line"><span class="comment">// Until the server replies to this request, it can't read another,</span></span><br><span class="line"><span class="comment">// so we might as well run the handler in this goroutine.</span></span><br><span class="line"><span class="comment">// [*] Not strictly true: HTTP pipelining. We could let them all process</span></span><br><span class="line"><span class="comment">// in parallel even if their responses need to be serialized.</span></span><br><span class="line"><span class="comment">// But we're not going to implement HTTP pipelining because it</span></span><br><span class="line"><span class="comment">// was never deployed in the wild and the answer is HTTP/2.</span></span><br><span class="line">serverHandler&#123;<span class="built_in">c</span>.server&#125;.<span class="type">ServeHTTP</span>(w, w.req)</span><br><span class="line">w.cancelCtx()</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">c</span>.hijacked() &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">w.finishRequest()</span><br><span class="line"><span class="keyword">if</span> !w.shouldReuseConnection() &#123;</span><br><span class="line"><span class="keyword">if</span> w.requestBodyLimitHit || w.closedRequestBodyEarly() &#123;</span><br><span class="line"><span class="built_in">c</span>.closeWriteAndWait()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">c</span>.setState(<span class="built_in">c</span>.rwc, <span class="type">StateIdle</span>)</span><br><span class="line"><span class="built_in">c</span>.curReq.<span class="type">Store</span>((*response)(<span class="literal">nil</span>))</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个连接建立之后，该连接中所有的请求都将在这个协程中进行处理，直到连接被关闭。在 <code>serve()</code> 方法中会循环调用<code>readRequest()</code> 方法读取下一个请求进行处理，其中最关键的逻辑就是一行代码：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">serverHandler</span>&#123;c.server&#125;.ServeHTTP(w, w<span class="meta">.req</span>)</span><br></pre></td></tr></table></figure><p>进一步解释 <code>serverHandler</code>：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">type serverHandler struct &#123;</span><br><span class="line">srv *Server</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request) &#123;</span><br><span class="line">handler := sh.srv.Handler</span><br><span class="line">if handler == nil &#123;</span><br><span class="line">handler = DefaultServeMux</span><br><span class="line">&#125;</span><br><span class="line">if req.RequestURI == <span class="string">"*"</span> &amp;&amp; req.Method == <span class="string">"<span class="keyword">OPTIONS</span>"</span> &#123;</span><br><span class="line">handler = globalOptionsHandler&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">handler.ServeHTTP(rw, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>serverHandler</code> 的 <code>ServeHTTP()</code> 方法里的 <code>sh.srv.Handler</code> 其实就是我们最初在 <code>http.ListenAndServe()</code> 中传入的 <code>Handler</code> 对象，也就是我们自定义的 <code>ServeMux</code> 对象。如果该 <code>Handler</code> 对象为 <code>nil</code>，则会使用默认的 <code>DefaultServeMux</code>。最后调用 <code>ServeMux</code> 的 <code>ServeHTTP()</code> 方法匹配当前路由对应的 <code>handler</code> 方法。</p><p>后面的逻辑就相对简单清晰了，主要在于调用 <code>ServeMux</code> 的 <code>match</code> 方法匹配到对应的已注册的路由表达式和 <code>handler</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServeHTTP dispatches the request to the handler whose</span></span><br><span class="line"><span class="comment">// pattern most closely matches the request URL.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> r.RequestURI == <span class="string">"*"</span> &#123;</span><br><span class="line"><span class="keyword">if</span> r.ProtoAtLeast(<span class="number">1</span>, <span class="number">1</span>) &#123;</span><br><span class="line">w.Header().Set(<span class="string">"Connection"</span>, <span class="string">"close"</span>)</span><br><span class="line">&#125;</span><br><span class="line">w.WriteHeader(StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">h, _ := mux.Handler(r)</span><br><span class="line">h.ServeHTTP(w, r)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">handler</span><span class="params">(host, path <span class="keyword">string</span>)</span> <span class="params">(h Handler, pattern <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">mux.mu.RLock()</span><br><span class="line"><span class="keyword">defer</span> mux.mu.RUnlock()</span><br><span class="line"><span class="comment">// Host-specific pattern takes precedence over generic ones</span></span><br><span class="line"><span class="keyword">if</span> mux.hosts &#123;</span><br><span class="line">h, pattern = mux.match(host + path)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">h, pattern = mux.match(path)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">h, pattern = NotFoundHandler(), <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find a handler on a handler map given a path string.</span></span><br><span class="line"><span class="comment">// Most-specific (longest) pattern wins.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">match</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="params">(h Handler, pattern <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// Check for exact match first.</span></span><br><span class="line">v, ok := mux.m[path]</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line"><span class="keyword">return</span> v.h, v.pattern</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Check for longest valid match.  mux.es contains all patterns</span></span><br><span class="line"><span class="comment">// that end in / sorted from longest to shortest.</span></span><br><span class="line"><span class="keyword">for</span> _, e := <span class="keyword">range</span> mux.es &#123;</span><br><span class="line"><span class="keyword">if</span> strings.HasPrefix(path, e.pattern) &#123;</span><br><span class="line"><span class="keyword">return</span> e.h, e.pattern</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="string">""</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>match</code> 方法里我们看到之前提到的 mux 的 <code>m</code> 字段(类型为 <code>map[string]muxEntry</code> )和 <code>es</code> (类型为 <code>[]muxEntry</code>)。这个方法里首先会利用进行精确匹配，在 <code>map[string]muxEntry</code> 中查找是否有对应的路由规则存在；如果没有匹配的路由规则，则会利用 <code>es</code> 进行近似匹配。</p><p>之前提到在注册路由时会把以 <code>&#39;/&#39;</code> 结尾的路由（可称为<strong>节点路由</strong>）加入到 <code>es</code> 字段的 <code>[]muxEntry</code> 中。对于类似 <code>/path1/path2/path3</code> 这样的路由，如果不能找到精确匹配的路由规则，那么则会去匹配和当前路由最接近的已注册的父节点路由，所以如果路由 <code>/path1/path2/</code> 已注册，那么该路由会被匹配，否则继续匹配下一个父节点路由，直到根路由 <code>/</code>。</p><p>由于 <code>[]muxEntry</code> 中的 <code>muxEntry</code> 按照路由表达式从长到短排序，所以进行近似匹配时匹配到的节点路由一定是已注册父节点路由中最相近的。</p><p>至此，Go 实现的 <code>http server</code> 的大致原理介绍完毕！</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Golang 通过 <code>ServeMux</code> 定义了一个多路器来管理路由，并通过 <code>Handler</code> 接口定义了路由处理函数的统一规范，即 <code>Handler</code> 都须实现 <code>ServeHTTP</code> 方法；同时 <code>Handler</code> 接口提供了强大的扩展性，方便开发者通过 <code>Handler</code> 接口实现各种中间件。相信大家阅读下来也能感受到 <code>Handler</code> 对象在 <code>server</code> 服务的实现中真的无处不在。理解了 <code>server</code> 实现的基本原理，大家就可以在此基础上阅读一些第三方的 <code>http server</code> 框架，以及编写特定功能的中间件。</p><p>以上。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://studygolang.com/pkgdoc" target="_blank" rel="noopener">【Golang标准库文档–net/http】</a></p><blockquote><p>转载自<a href="https://juejin.im/post/5dd11baff265da0c0c1fe813#heading-2" target="_blank" rel="noopener">掘金</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>一文详解微服务架构</title>
      <link href="//blog/%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.html"/>
      <url>//blog/%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文将介绍微服务架构和相关的组件，介绍他们是什么以及为什么要使用微服务架构和这些组件。本文侧重于简明地表达微服务架构的全局图景，因此不会涉及具体如何使用组件等细节。</p></blockquote><p>要理解微服务，首先要先理解不是微服务的那些。通常跟微服务相对的是单体应用，即将所有功能都打包成在一个独立单元的应用程序。从单体应用到微服务并不是一蹴而就的，这是一个逐渐演变的过程。本文将以一个网上超市应用为例来说明这一过程。</p><a id="more"></a><h2 id="最初的需求"><a href="#最初的需求" class="headerlink" title="最初的需求"></a>最初的需求</h2><p>几年前，小明和小皮一起创业做网上超市。小明负责程序开发，小皮负责其他事宜。当时互联网还不发达，网上超市还是蓝海。只要功能实现了就能随便赚钱。所以他们的需求很简单，只需要一个网站挂在公网，用户能够在这个网站上浏览商品、购买商品；另外还需一个管理后台，可以管理商品、用户、以及订单数据。</p><p>我们整理一下功能清单：</p><ul><li>网站</li><li>用户注册、登录功能</li><li>商品展示</li><li>下单</li><li>管理后台</li><li>用户管理</li><li>商品管理</li><li>订单管理</li></ul><p>由于需求简单，小明左手右手一个慢动作，网站就做好了。管理后台出于安全考虑，不和网站做在一起，小明右手左手慢动作重播，管理网站也做好了。总体架构图如下：</p><p><img src="https://cdn.learnku.com/uploads/images/201911/12/36517/u9vENRJRvy.png!large" alt="Golang"></p><p>小明挥一挥手，找了家云服务部署上去，网站就上线了。上线后好评如潮，深受各类肥宅喜爱。小明小皮美滋滋地开始躺着收钱。</p><h2 id="随着业务发展……"><a href="#随着业务发展……" class="headerlink" title="随着业务发展……"></a>随着业务发展……</h2><p>好景不长，没过几天，各类网上超市紧跟着拔地而起，对小明小皮造成了强烈的冲击。</p><p>在竞争的压力下，小明小皮决定开展一些营销手段：</p><p>开展促销活动。比如元旦全场打折，春节买二送一，情人节狗粮优惠券等等。<br>拓展渠道，新增移动端营销。除了网站外，还需要开发移动端APP，微信小程序等。<br>精准营销。利用历史数据对用户进行分析，提供个性化服务。<br>……<br>这些活动都需要程序开发的支持。小明拉了同学小红加入团队。小红负责数据分析以及移动端相关开发。小明负责促销活动相关功能的开发。</p><p>因为开发任务比较紧迫，小明小红没有好好规划整个系统的架构，随便拍了拍脑袋，决定把促销管理和数据分析放在管理后台里，微信和移动端APP另外搭建。通宵了几天后，新功能和新应用基本完工。这时架构图如下：</p><p><img src="https://cdn.learnku.com/uploads/images/201911/12/36517/FjPjhxb0aG.png!large" alt="Golang"></p><p>这一阶段存在很多不合理的地方：</p><p>网站和移动端应用有很多相同业务逻辑的重复代码。<br>数据有时候通过数据库共享，有时候通过接口调用传输。接口调用关系杂乱。<br>单个应用为了给其他应用提供接口，渐渐地越改越大，包含了很多本来就不属于它的逻辑。应用边界模糊，功能归属混乱。<br>管理后台在一开始的设计中保障级别较低。加入数据分析和促销管理相关功能后出现性能瓶颈，影响了其他应用。<br>数据库表结构被多个应用依赖，无法重构和优化。<br>所有应用都在一个数据库上操作，数据库出现性能瓶颈。特别是数据分析跑起来的时候，数据库性能急剧下降。<br>开发、测试、部署、维护愈发困难。即使只改动一个小功能，也需要整个应用一起发布。有时候发布会不小心带上了一些未经测试的代码，或者修改了一个功能后，另一个意想不到的地方出错了。为了减轻发布可能产生的问题的影响和线上业务停顿的影响，所有应用都要在凌晨三四点执行发布。发布后为了验证应用正常运行，还得盯到第二天白天的用户高峰期……<br>团队出现推诿扯皮现象。关于一些公用的功能应该建设在哪个应用上的问题常常要争论很久，最后要么干脆各做各的，或者随便放个地方但是都不维护。<br>尽管有着诸多问题，但也不能否认这一阶段的成果：快速地根据业务变化建设了系统。不过紧迫且繁重的任务容易使人陷入局部、短浅的思维方式，从而做出妥协式的决策。在这种架构中，每个人都只关注在自己的一亩三分地，缺乏全局的、长远的设计。长此以往，系统建设将会越来越困难，甚至陷入不断推翻、重建的循环。</p><h2 id="是时候做出改变了"><a href="#是时候做出改变了" class="headerlink" title="是时候做出改变了"></a>是时候做出改变了</h2><p>幸好小明和小红是有追求有理想的好青年。意识到问题后，小明和小红从琐碎的业务需求中腾出了一部分精力，开始梳理整体架构，针对问题准备着手改造。</p><p>要做改造，首先你需要有足够的精力和资源。如果你的需求方（业务人员、项目经理、上司等）很强势地一心追求需求进度，以致于你无法挪出额外的精力和资源的话，那么你可能无法做任何事……</p><p>在编程的世界中，最重要的便是抽象能力。微服务改造的过程实际上也是个抽象的过程。小明和小红整理了网上超市的业务逻辑，抽象出公用的业务能力，做成几个公共服务：</p><ul><li>用户服务</li><li>商品服务</li><li>促销服务</li><li>订单服务</li><li>数据分析服务</li></ul><p>各个应用后台只需从这些服务获取所需的数据，从而删去了大量冗余的代码，就剩个轻薄的控制层和前端。这一阶段的架构如下：</p><p><img src="https://cdn.learnku.com/uploads/images/201911/12/36517/caekLeNsCl.png!large" alt="Golang"></p><p>这个阶段只是将服务分开了，数据库依然是共用的，所以一些烟囱式系统的缺点仍然存在：</p><p>数据库成为性能瓶颈，并且有单点故障的风险。<br>数据管理趋向混乱。即使一开始有良好的模块化设计，随着时间推移，总会有一个服务直接从数据库取另一个服务的数据的现象。<br>数据库表结构可能被多个服务依赖，牵一发而动全身，很难调整。<br>如果一直保持共用数据库的模式，则整个架构会越来越僵化，失去了微服务架构的意义。因此小明和小红一鼓作气，把数据库也拆分了。所有持久化层相互隔离，由各个服务自己负责。另外，为了提高系统的实时性，加入了消息队列机制。架构如下：</p><p><img src="https://cdn.learnku.com/uploads/images/201911/12/36517/rhKOdrgLLe.png!large" alt="Golang"></p><p>完全拆分后各个服务可以采用异构的技术。比如数据分析服务可以使用数据仓库作为持久化层，以便于高效地做一些统计计算；商品服务和促销服务访问频率比较大，因此加入了缓存机制等。</p><p>还有一种抽象出公共逻辑的方法是把这些公共逻辑做成公共的框架库。这种方法可以减少服务调用的性能损耗。但是这种方法的管理成本非常高昂，很难保证所有应用版本的一致性。</p><p>数据库拆分也有一些问题和挑战：比如说跨库级联的需求，通过服务查询数据颗粒度的粗细问题等。但是这些问题可以通过合理的设计来解决。总体来说，数据库拆分是一个利大于弊的。</p><p>微服务架构还有一个技术外的好处，它使整个系统的分工更加明确，责任更加清晰，每个人专心负责为其他人提供更好的服务。在单体应用的时代，公共的业务功能经常没有明确的归属。最后要么各做各的，每个人都重新实现了一遍；要么是随机一个人（一般是能力比较强或者比较热心的人）做到他负责的应用里面。在后者的情况下，这个人在负责自己应用之外，还要额外负责给别人提供这些公共的功能——而这个功能本来是无人负责的，仅仅因为他能力较强/比较热心，就莫名地背锅（这种情况还被美其名曰能者多劳）。结果最后大家都不愿意提供公共的功能。长此以往，团队里的人渐渐变得各自为政，不再关心全局的架构设计。</p><p>从这个角度上看，使用微服务架构同时也需要组织结构做相应的调整。所以说做微服务改造需要管理者的支持。</p><p>改造完成后，小明和小红分清楚各自的锅。两人十分满意，一切就像是麦克斯韦方程组一样漂亮完美。</p><p>然而……</p><h2 id="没有银弹"><a href="#没有银弹" class="headerlink" title="没有银弹"></a>没有银弹</h2><p>春天来了，万物复苏，又到了一年一度的购物狂欢节。眼看着日订单数量蹭蹭地上涨，小皮小明小红喜笑颜开。可惜好景不长，乐极生悲，突然嘣的一下，系统挂了。</p><p>以往单体应用，排查问题通常是看一下日志，研究错误信息和调用堆栈。而微服务架构整个应用分散成多个服务，定位故障点非常困难。小明一个台机器一台机器地查看日志，一个服务一个服务地手工调用。经过十几分钟的查找，小明终于定位到故障点：促销服务由于接收的请求量太大而停止响应了。其他服务都直接或间接地会调用促销服务，于是也跟着宕机了。在微服务架构中，一个服务故障可能会产生雪崩效用，导致整个系统故障。其实在节前，小明和小红是有做过请求量评估的。按照预计，服务器资源是足以支持节日的请求量的，所以肯定是哪里出了问题。不过形势紧急，随着每一分每一秒流逝的都是白花花的银子，因此小明也没时间排查问题，当机立断在云上新建了几台虚拟机，然后一台一台地部署新的促销服务节点。几分钟的操作后，系统总算是勉强恢复正常了。整个故障时间内估计损失了几十万的销售额，三人的心在滴血……</p><p>事后，小明简单写了个日志分析工具（量太大了，文本编辑器几乎打不开，打开了肉眼也看不过来），统计了促销服务的访问日志，发现在故障期间，商品服务由于代码问题，在某些场景下会对促销服务发起大量请求。这个问题并不复杂，小明手指抖一抖，修复了这个价值几十万的Bug。</p><p>问题是解决了，但谁也无法保证不会再发生类似的其他问题。微服务架构虽然逻辑设计上看是完美的，但就像积木搭建的华丽宫殿一样，经不起风吹草动。微服务架构虽然解决了旧问题，也引入了新的问题：</p><p>微服务架构整个应用分散成多个服务，定位故障点非常困难。<br>稳定性下降。服务数量变多导致其中一个服务出现故障的概率增大，并且一个服务故障可能导致整个系统挂掉。事实上，在大访问量的生产场景下，故障总是会出现的。<br>服务数量非常多，部署、管理的工作量很大。<br>开发方面：如何保证各个服务在持续开发的情况下仍然保持协同合作。<br>测试方面：服务拆分后，几乎所有功能都会涉及多个服务。原本单个程序的测试变为服务间调用的测试。测试变得更加复杂。<br>小明小红痛定思痛，决心好好解决这些问题。对故障的处理一般从两方面入手，一方面尽量减少故障发生的概率，另一方面降低故障造成的影响。</p><p><img src="https://cdn.learnku.com/uploads/images/201911/12/36517/mCItMKSarC.png!large" alt="Golang"></p><h2 id="监控-发现故障的征兆"><a href="#监控-发现故障的征兆" class="headerlink" title="监控 - 发现故障的征兆"></a>监控 - 发现故障的征兆</h2><p>在高并发分布式的场景下，故障经常是突然间就雪崩式爆发。所以必须建立完善的监控体系，尽可能发现故障的征兆。</p><p>微服务架构中组件繁多，各个组件所需要监控的指标不同。比如Redis缓存一般监控占用内存值、网络流量，数据库监控连接数、磁盘空间，业务服务监控并发数、响应延迟、错误率等。因此如果做一个大而全的监控系统来监控各个组件是不大现实的，而且扩展性会很差。一般的做法是让各个组件提供报告自己当前状态的接口（metrics接口），这个接口输出的数据格式应该是一致的。然后部署一个指标采集器组件，定时从这些接口获取并保持组件状态，同时提供查询服务。最后还需要一个UI，从指标采集器查询各项指标，绘制监控界面或者根据阈值发出告警。</p><p>大部分组件都不需要自己动手开发，网络上有开源组件。小明下载了RedisExporter和MySQLExporter，这两个组件分别提供了Redis缓存和MySQL数据库的指标接口。微服务则根据各个服务的业务逻辑实现自定义的指标接口。然后小明采用Prometheus作为指标采集器，Grafana配置监控界面和邮件告警。这样一套微服务监控系统就搭建起来了：</p><p><img src="https://cdn.learnku.com/uploads/images/201911/12/36517/sVc5Z1edNL.png!large" alt="Golang"></p><h2 id="定位问题-链路跟踪"><a href="#定位问题-链路跟踪" class="headerlink" title="定位问题 - 链路跟踪"></a>定位问题 - 链路跟踪</h2><p>在微服务架构下，一个用户的请求往往涉及多个内部服务调用。为了方便定位问题，需要能够记录每个用户请求时，微服务内部产生了多少服务调用，及其调用关系。这个叫做链路跟踪。</p><p>我们用一个Istio文档里的链路跟踪例子来看看效果：</p><p><img src="https://cdn.learnku.com/uploads/images/201911/12/36517/dWAyNf8VHZ.png!large" alt="Golang"></p><p>图片来自Istio文档</p><p>从图中可以看到，这是一个用户访问productpage页面的请求。在请求过程中，productpage服务顺序调用了details和reviews服务的接口。而reviews服务在响应过程中又调用了ratings的接口。整个链路跟踪的记录是一棵树：</p><p><img src="https://cdn.learnku.com/uploads/images/201911/12/36517/Sc6uKRw4r8.png!large" alt="Golang"></p><p>要实现链路跟踪，每次服务调用会在HTTP的HEADERS中记录至少记录四项数据：</p><p>traceId：traceId标识一个用户请求的调用链路。具有相同traceId的调用属于同一条链路。<br>spanId：标识一次服务调用的ID，即链路跟踪的节点ID。<br>parentId：父节点的spanId。<br>requestTime &amp; responseTime：请求时间和响应时间。<br>另外，还需要调用日志收集与存储的组件，以及展示链路调用的UI组件。</p><p><img src="https://cdn.learnku.com/uploads/images/201911/12/36517/IQcJmVeDbV.png!large" alt="Golang"></p><p>以上只是一个极简的说明，关于链路跟踪的理论依据可详见Google的Dapper</p><p>了解了理论基础后，小明选用了Dapper的一个开源实现Zipkin。然后手指一抖，写了个HTTP请求的拦截器，在每次HTTP请求时生成这些数据注入到HEADERS，同时异步发送调用日志到Zipkin的日志收集器中。这里额外提一下，HTTP请求的拦截器，可以在微服务的代码中实现，也可以使用一个网络代理组件来实现（不过这样子每个微服务都需要加一层代理）。</p><p>链路跟踪只能定位到哪个服务出现问题，不能提供具体的错误信息。查找具体的错误信息的能力则需要由日志分析组件来提供。</p><h2 id="分析问题-日志分析"><a href="#分析问题-日志分析" class="headerlink" title="分析问题 - 日志分析"></a>分析问题 - 日志分析</h2><p>日志分析组件应该在微服务兴起之前就被广泛使用了。即使单体应用架构，当访问数变大、或服务器规模增多时，日志文件的大小会膨胀到难以用文本编辑器进行访问，更糟的是它们分散在多台服务器上面。排查一个问题，需要登录到各台服务器去获取日志文件，一个一个地查找（而且打开、查找都很慢）想要的日志信息。</p><p>因此，在应用规模变大时，我们需要一个日志的“搜索引擎”。以便于能准确的找到想要的日志。另外，数据源一侧还需要收集日志的组件和展示结果的UI组件：</p><p><img src="https://cdn.learnku.com/uploads/images/201911/12/36517/KRhba2asz2.png!large" alt="Golang"></p><p>小明调查了一下，使用了大名鼎鼎地ELK日志分析组件。ELK是Elasticsearch、Logstash和Kibana三个组件的缩写。</p><ul><li>Elasticsearch：搜索引擎，同时也是日志的存储。</li><li>Logstash：日志采集器，它接收日志输入，对日志进行一些预处理，然后输出到Elasticsearch。</li><li>Kibana：UI组件，通过Elasticsearch的API查找数据并展示给用户。</li></ul><p>最后还有一个小问题是如何将日志发送到Logstash。一种方案是在日志输出的时候直接调用Logstash接口将日志发送过去。这样一来又（咦，为啥要用“又”）要修改代码……于是小明选用了另一种方案：日志仍然输出到文件，每个服务里再部署个Agent扫描日志文件然后输出给Logstash。</p><h2 id="网关-权限控制，服务治理"><a href="#网关-权限控制，服务治理" class="headerlink" title="网关 - 权限控制，服务治理"></a>网关 - 权限控制，服务治理</h2><p>拆分成微服务后，出现大量的服务，大量的接口，使得整个调用关系乱糟糟的。经常在开发过程中，写着写着，忽然想不起某个数据应该调用哪个服务。或者写歪了，调用了不该调用的服务，本来一个只读的功能结果修改了数据……</p><p>为了应对这些情况，微服务的调用需要一个把关的东西，也就是网关。在调用者和被调用者中间加一层网关，每次调用时进行权限校验。另外，网关也可以作为一个提供服务接口文档的平台。</p><p>使用网关有一个问题就是要决定在多大粒度上使用：最粗粒度的方案是整个微服务一个网关，微服务外部通过网关访问微服务，微服务内部则直接调用；最细粒度则是所有调用，不管是微服务内部调用或者来自外部的调用，都必须通过网关。折中的方案是按照业务领域将微服务分成几个区，区内直接调用，区间通过网关调用。</p><p>由于整个网上超市的服务数量还不算特别多，小明采用的最粗粒度的方案：</p><p><img src="https://cdn.learnku.com/uploads/images/201911/12/36517/UzJqCocJwY.png!large" alt="Golang"></p><h2 id="服务注册与发现-动态扩容"><a href="#服务注册与发现-动态扩容" class="headerlink" title="服务注册与发现 - 动态扩容"></a>服务注册与发现 - 动态扩容</h2><p>前面的组件，都是旨在降低故障发生的可能性。然而故障总是会发生的，所以另一个需要研究的是如何降低故障产生的影响。</p><p>最粗暴的（也是最常用的）故障处理策略就是冗余。一般来说，一个服务都会部署多个实例，这样一来能够分担压力提高性能，二来即使一个实例挂了其他实例还能响应。</p><p>冗余的一个问题是使用几个冗余？这个问题在时间轴上并没有一个切确的答案。根据服务功能、时间段的不同，需要不同数量的实例。比如在平日里，可能4个实例已经够用；而在促销活动时，流量大增，可能需要40个实例。因此冗余数量并不是一个固定的值，而是根据需要实时调整的。</p><p>一般来说新增实例的操作为：</p><ol><li>部署新实例</li><li>将新实例注册到负载均衡或DNS上<br>操作只有两步，但如果注册到负载均衡或DNS的操作为人工操作的话，那事情就不简单了。想想新增40个实例后，要手工输入40个IP的感觉……</li></ol><p>解决这个问题的方案是服务自动注册与发现。首先，需要部署一个服务发现服务，它提供所有已注册服务的地址信息的服务。DNS也算是一种服务发现服务。然后各个应用服务在启动时自动将自己注册到服务发现服务上。并且应用服务启动后会实时（定期）从服务发现服务同步各个应用服务的地址列表到本地。服务发现服务也会定期检查应用服务的健康状态，去掉不健康的实例地址。这样新增实例时只需要部署新实例，实例下线时直接关停服务即可，服务发现会自动检查服务实例的增减。</p><p><img src="https://cdn.learnku.com/uploads/images/201911/12/36517/uaAV0WH1LK.png!large" alt="Golang"></p><p>服务发现还会跟客户端负载均衡配合使用。由于应用服务已经同步服务地址列表在本地了，所以访问微服务时，可以自己决定负载策略。甚至可以在服务注册时加入一些元数据（服务版本等信息），客户端负载则根据这些元数据进行流量控制，实现A/B测试、蓝绿发布等功能。</p><p>服务发现有很多组件可以选择，比如说Zookeeper 、Eureka、Consul、Etcd等。不过小明觉得自己水平不错，想炫技，于是基于Redis自己写了一个……</p><h2 id="熔断、服务降级、限流"><a href="#熔断、服务降级、限流" class="headerlink" title="熔断、服务降级、限流"></a>熔断、服务降级、限流</h2><h3 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h3><p>当一个服务因为各种原因停止响应时，调用方通常会等待一段时间，然后超时或者收到错误返回。如果调用链路比较长，可能会导致请求堆积，整条链路占用大量资源一直在等待下游响应。所以当多次访问一个服务失败时，应熔断，标记该服务已停止工作，直接返回错误。直至该服务恢复正常后再重新建立连接。</p><p><img src="https://cdn.learnku.com/uploads/images/201911/12/36517/yetpquXnyW.png!large" alt="Golang"></p><p>图片来自《微服务设计》</p><h3 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h3><p>当下游服务停止工作后，如果该服务并非核心业务，则上游服务应该降级，以保证核心业务不中断。比如网上超市下单界面有一个推荐商品凑单的功能，当推荐模块挂了后，下单功能不能一起挂掉，只需要暂时关闭推荐功能即可。</p><h3 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h3><p>一个服务挂掉后，上游服务或者用户一般会习惯性地重试访问。这导致一旦服务恢复正常，很可能因为瞬间网络流量过大又立刻挂掉，在棺材里重复着仰卧起坐。因此服务需要能够自我保护——限流。限流策略有很多，最简单的比如当单位时间内请求数过多时，丢弃多余的请求。另外，也可以考虑分区限流。仅拒绝来自产生大量请求的服务的请求。例如商品服务和订单服务都需要访问促销服务，商品服务由于代码问题发起了大量请求，促销服务则只限制来自商品服务的请求，来自订单服务的请求则正常响应。</p><p><img src="https://cdn.learnku.com/uploads/images/201911/12/36517/nfIeXLpbil.png!large" alt="Golang"></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>微服务架构下，测试分为三个层次：</p><ol><li>端到端测试：覆盖整个系统，一般在用户界面机型测试。</li><li>服务测试：针对服务接口进行测试。</li><li>单元测试：针对代码单元进行测试。<br>三种测试从上到下实施的容易程度递增，但是测试效果递减。端到端测试最费时费力，但是通过测试后我们对系统最有信心。单元测试最容易实施，效率也最高，但是测试后不能保证整个系统没有问题。</li></ol><p><img src="https://cdn.learnku.com/uploads/images/201911/12/36517/9Jcgwx4zwg.png!large" alt="Golang"></p><p>由于端到端测试实施难度较大，一般只对核心功能做端到端测试。一旦端到端测试失败，则需要将其分解到单元测试：则分析失败原因，然后编写单元测试来重现这个问题，这样未来我们便可以更快地捕获同样的错误。</p><p>服务测试的难度在于服务会经常依赖一些其他服务。这个问题可以通过Mock Server解决：</p><p><img src="https://cdn.learnku.com/uploads/images/201911/12/36517/QzyhkVLrhh.png!large" alt="Golang"></p><p>单元测试大家都很熟悉了。我们一般会编写大量的单元测试（包括回归测试）尽量覆盖所有代码。</p><h2 id="微服务框架"><a href="#微服务框架" class="headerlink" title="微服务框架"></a>微服务框架</h2><p>指标接口、链路跟踪注入、日志引流、服务注册发现、路由规则等组件以及熔断、限流等功能都需要在应用服务上添加一些对接代码。如果让每个应用服务自己实现是非常耗时耗力的。基于DRY的原则，小明开发了一套微服务框架，将与各个组件对接的代码和另外一些公共代码抽离到框架中，所有的应用服务都统一使用这套框架进行开发。</p><p>使用微服务框架可以实现很多自定义的功能。甚至可以将程序调用堆栈信息注入到链路跟踪，实现代码级别的链路跟踪。或者输出线程池、连接池的状态信息，实时监控服务底层状态。</p><p>使用统一的微服务框架有一个比较严重的问题：框架更新成本很高。每次框架升级，都需要所有应用服务配合升级。当然，一般会使用兼容方案，留出一段并行时间等待所有应用服务升级。但是如果应用服务非常多时，升级时间可能会非常漫长。并且有一些很稳定几乎不更新的应用服务，其负责人可能会拒绝升级……因此，使用统一微服务框架需要完善的版本管理方法和开发管理规范。</p><h2 id="另一条路-Service-Mesh"><a href="#另一条路-Service-Mesh" class="headerlink" title="另一条路 - Service Mesh"></a>另一条路 - Service Mesh</h2><p>另一种抽象公共代码的方法是直接将这些代码抽象到一个反向代理组件。每个服务都额外部署这个代理组件，所有出站入站的流量都通过该组件进行处理和转发。这个组件被称为Sidecar。</p><blockquote><p>Sidecar不会产生额外网络成本。Sidecar会和微服务节点部署在同一台主机上并且共用相同的虚拟网卡。所以sidecar和微服务节点的通信实际上都只是通过内存拷贝实现的。</p></blockquote><p><img src="https://cdn.learnku.com/uploads/images/201911/12/36517/xrKZfq3ZaA.png!large" alt="Golang"></p><p>图片来自：Pattern: Service Mesh</p><p>Sidecar只负责网络通信。还需要有个组件来统一管理所有sidecar的配置。在Service Mesh中，负责网络通信的部分叫数据平面（data plane），负责配置管理的部分叫控制平面（control plane）。数据平面和控制平面构成了Service Mesh的基本架构。</p><p><img src="https://cdn.learnku.com/uploads/images/201911/12/36517/NhwMTWXRz2.png!large" alt="Golang"></p><p>图片来自：Pattern: Service Mesh</p><p>Sevice Mesh相比于微服务框架的优点在于它不侵入代码，升级和维护更方便。它经常被诟病的则是性能问题。即使回环网络不会产生实际的网络请求，但仍然有内存拷贝的额外成本。另外有一些集中式的流量处理也会影响性能。</p><h2 id="结束、也是开始"><a href="#结束、也是开始" class="headerlink" title="结束、也是开始"></a>结束、也是开始</h2><p>微服务不是架构演变的终点。往细走还有Serverless、FaaS等方向。另一方面也有人在唱合久必分分久必合，重新发现单体架构……</p><p>不管怎样，微服务架构的改造暂时告一段落了。小明满足地摸了摸日益光滑的脑袋，打算这个周末休息一下约小红喝杯咖啡。</p><blockquote><p>本文转载自 <a href="https://www.cnblogs.com/skabyy/p/11396571.html" target="_blank" rel="noopener">cnblog</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何用GVM管理Go项目</title>
      <link href="//blog/%E5%A6%82%E4%BD%95%E7%94%A8GVM%E7%AE%A1%E7%90%86Go%E9%A1%B9%E7%9B%AE.html"/>
      <url>//blog/%E5%A6%82%E4%BD%95%E7%94%A8GVM%E7%AE%A1%E7%90%86Go%E9%A1%B9%E7%9B%AE.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用 Go 版本管理器管理多个版本的 Go 语言环境及其模块</p></blockquote><p><img src="https://cdn.learnku.com/uploads/images/201910/18/36517/ZDHqtzEHMw.png!large" alt="如何用 GVM 管理 Go 项目"></p><p>Go 语言版本管理器（<a href="https://github.com/moovweb/gvm" target="_blank" rel="noopener">GVM</a>）是管理 Go 语言环境的开源工具。GVM 「pkgsets」 支持安装多个版本的 Go 并管理每个项目的模块。它最初由 <a href="https://github.com/jbussdieker" target="_blank" rel="noopener">Josh Bussdieker</a> 开发，GVM（像它的对手 Ruby RVM 一样）允许你为每个项目或一组项目创建一个开发环境，分离不同的 Go 版本和包依赖关系，来提供更大的灵活性，以防不同版本造成的问题。</p><p>有几种管理 Go 包的方式，包括 Go 1.11 内置于 Go 中的 Modules。我发现GVM简单而直观，即使我不使用它来管理包，我仍然会使用它来管理不同的 Go 版本。</p><a id="more"></a><h2 id="安装-GVM"><a href="#安装-GVM" class="headerlink" title="安装 GVM"></a>安装 GVM</h2><p>安装 GVM 很简单。<a href="https://github.com/moovweb/gvm#installation" target="_blank" rel="noopener">GVM库</a>安装文档指导您下载安装脚本并将其导入 Bash。</p><p><code>bash &lt; &lt;(curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer)</code></p><p>尽管越来越多的人采用这种安装方法，但最好还是在安装之前先看看安装程序在做什么。以 GVM 为例，安装脚本执行过程：</p><ol><li>检查相关依赖</li><li>克隆 GVM 库</li><li>使用 shell 脚本:<ul><li>安装 Go 语言</li><li>管理 GOPATH 环境变量</li><li>在 bashrc 、zshrc 或配置文件中添加一行内容</li></ul></li></ol><p>如果您想再次检查它在做什么，您可以克隆库并检查 shel l脚本，然后运行 <code>./binscripts/gvm-installer</code> 使用本地脚本进行设置。</p><p><em>注意:</em> 由于 GVM 可用于下载和编译新的 Go 版本，因此会有一些预期的依赖项，如 Make，Git 和 Curl。你可以在<a href="https://github.com/moovweb/gvm/blob/master/README.md" target="_blank" rel="noopener">GVM 的 README</a> 中找到完整的发行版列表。</p><h2 id="使用-GVM-安装和管理-Go-版本"><a href="#使用-GVM-安装和管理-Go-版本" class="headerlink" title="使用 GVM 安装和管理 Go 版本"></a>使用 GVM 安装和管理 Go 版本</h2><p>一旦安装了 GVM，您就可以开始使用它来安装和管理不同版本的 Go。<code>gvm listall</code> 命令显示了可以下载和编译的可用的 Go 版本：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[chris@marvin ]$ gvm listall</span><br><span class="line">$ gvm listall</span><br><span class="line"></span><br><span class="line">gvm gos (available)</span><br><span class="line"></span><br><span class="line">   go1</span><br><span class="line">   go1<span class="number">.0</span><span class="number">.1</span></span><br><span class="line">   go1<span class="number">.0</span><span class="number">.2</span></span><br><span class="line">   go1<span class="number">.0</span><span class="number">.3</span></span><br><span class="line"></span><br><span class="line">&lt;输出截断&gt;</span><br></pre></td></tr></table></figure><p>安装特定的 Go 版本就想 <code>gvm install &lt;version&gt;</code> 一样简单，其中 <code>&lt;version&gt;</code> 是 <code>gvm install</code> 命令返回的版本之一。</p><p>假设您正在处理一个使用 Go 1.12.8 版本的项目。你可以使用 <code>gvm install go1.12.8</code> 命令来安装这个版本:</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[chris@marvin]$ gvm install go1<span class="number">.12</span><span class="number">.8</span></span><br><span class="line">Installing go1<span class="number">.12</span><span class="number">.8</span>...</span><br><span class="line"> * Compiling...</span><br><span class="line">go1<span class="number">.12</span><span class="number">.8</span> successfully installed!</span><br></pre></td></tr></table></figure><p>输入 <code>gvm list</code>，你会看到 Go 1.12.8 版本与系统 Go 版本（使用操作系统的软件包管理器打包的版本）同时存在：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[chris@marvin]$ gvm list</span><br><span class="line">gvm gos (installed)</span><br><span class="line">   <span class="symbol">go1</span>.<span class="number">12.8</span></span><br><span class="line">=&gt; system</span><br></pre></td></tr></table></figure><p>GVM 仍然再使用系统的 Go 版本，通过它旁边的 <strong>=&gt;</strong> 符号来表示。你可以使用 <code>gvm use</code> 命令来切换到新安装的 go1.12.8版本：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[chris@marvin]$ gvm <span class="keyword">use</span> go1<span class="number">.12</span><span class="number">.8</span></span><br><span class="line"><span class="keyword">Now</span> <span class="keyword">using</span> <span class="keyword">version</span> go1<span class="number">.12</span><span class="number">.8</span></span><br><span class="line">[chris@marvin]$ <span class="keyword">go</span> <span class="keyword">version</span></span><br><span class="line"><span class="keyword">go</span> <span class="keyword">version</span> go1<span class="number">.12</span><span class="number">.8</span> linux/amd64</span><br></pre></td></tr></table></figure><p>GVM使管理已安装的Go版本变得极其简单，但它不止如此！</p><h2 id="使用-GVM-pkgset"><a href="#使用-GVM-pkgset" class="headerlink" title="使用 GVM pkgset"></a>使用 GVM pkgset</h2><p>在开箱即用的情况下，Go 以一种出色而又令人沮丧的方式管理包和模块。默认情况下，如果你 <code>go get</code> 获取一个包，它会被下载到  <code>$GOPATH</code> 目录中的 <code>src</code> 和 <code>pkg</code> 目录下；然后你可以使用 <code>import</code> 将其引入到你的 Go 程序中。这使得获取包变得很容易，特别是对于没有特权的用户，不需要 <code>sudo</code> 或 root 特权(很像 Python 中的<code>pip install --user</code>)。然而，在不同的项目中管理相同包的不同版本是困难的。</p><p>有许多方法可以尝试修复或缓解这个问题，包括实验性的 Go Modules (在 Go v1.11 版本中增加了初步支持)和 <a href="https://golang.github.io/dep/" target="_blank" rel="noopener">Go dep</a>(一个「官方实验」，被正在被 Go Modules 所替代)。在我发现GVM之前，为了确保隔离，我会在自己的Docker容器中构建和测试Go项目。</p><p>GVM 通过使用「pkgsets」将项目的新目录附加到 Go 安装版本的默认 <code>$GOPATH</code>，很像在 Unix/Linux 系统上工作的<code>$PATH</code>，很好地完成了项目之间包的管理和隔离。</p><p>很容易想象这是如何运行的。首先，安装新版本的Go 1.12.9：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[chris@marvin]$ echo $GOPATH</span><br><span class="line">/home/chris/.gvm/pkgsets/go1<span class="meta">.12</span><span class="meta">.8</span>/<span class="meta">global</span></span><br><span class="line">[chris@marvin]$ gvm install go1<span class="meta">.12</span><span class="meta">.9</span></span><br><span class="line">Installing go1<span class="meta">.12</span><span class="meta">.9</span>...</span><br><span class="line"> * Compiling...</span><br><span class="line">go1<span class="meta">.12</span><span class="meta">.9</span> successfully installed</span><br><span class="line">[chris@marvin]$ gvm use go1<span class="meta">.12</span><span class="meta">.9</span></span><br><span class="line">Now using version go1<span class="meta">.12</span><span class="meta">.9</span></span><br></pre></td></tr></table></figure><p>当 GVM 被告知使用一个新版本时，它将会更换一个新的 <code>$GOPATH</code>，<strong>gloabl</strong> pkgset 将默认使用该版本：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[chris@marvin]$ echo $GOPATH</span><br><span class="line">/home/chris/.gvm/pkgsets/<span class="symbol">go1</span>.<span class="number">12.9</span>/global</span><br><span class="line">[chris@marvin]$ gvm pkgset list</span><br><span class="line">gvm go package sets (<span class="symbol">go1</span>.<span class="number">12.9</span>)</span><br><span class="line">=&gt;  global</span><br></pre></td></tr></table></figure><p>尽管默认情况下没有安装额外的包，但是 global pkgset 中的包对于使用这个特定版本 Go 的任何项目都是可用的。</p><p>现在，假设您正在启动一个新项目，它需要一个特定的包。首先，使用 GVM 创建一个名为 <code>introToGvm</code> 的新的pkgset：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[chris@marvin]$ gvm pkgset create introToGvm</span><br><span class="line">[chris@marvin]$ gvm pkgset use introToGvm</span><br><span class="line"><span class="built_in">Now</span> using version <span class="symbol">go1</span>.<span class="number">12.9</span>@introToGvm</span><br><span class="line">[chris@marvin]$ gvm pkgset list</span><br><span class="line">gvm go package sets (<span class="symbol">go1</span>.<span class="number">12.9</span>)</span><br><span class="line">    global</span><br><span class="line">=&gt;  introToGvm</span><br></pre></td></tr></table></figure><p>如上所述，pkgset 的一个新目录被添加到 <code>$GOPATH</code>：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[chris<span class="meta">@marvin</span>]$ echo $GOPATH</span><br><span class="line"><span class="regexp">/home/</span>chris<span class="regexp">/.gvm/</span>pkgsets<span class="regexp">/go1.12.9/</span><span class="string">introToGvm:</span><span class="regexp">/home/</span>chris<span class="regexp">/.gvm/</span>pkgsets<span class="regexp">/go1.12.9/</span>global</span><br></pre></td></tr></table></figure><p>将目录更改为预先设置的 <code>introToGvm</code> 路径，并检查目录结构，然后利用这个机会体验一下 <code>awk</code> 和 <code>bash</code> 的乐趣:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[chris<span class="variable">@marvin</span>]<span class="variable">$ </span>cd <span class="variable">$(</span> awk -F<span class="string">':'</span> <span class="string">'&#123;print $1&#125;'</span> &lt;&lt;&lt; <span class="variable">$GOPATH</span> )</span><br><span class="line">[chris<span class="variable">@marvin</span>]<span class="variable">$ </span>pwd</span><br><span class="line">/home/chris/.gvm/pkgsets/go1.<span class="number">12.9</span>/introToGvm</span><br><span class="line">[chris<span class="variable">@marvin</span>]<span class="variable">$ </span>ls</span><br><span class="line">overlay  pkg  src</span><br></pre></td></tr></table></figure><p>注意，新目录看起来很像普通的 <code>$GOPATH</code>。新的 Go 包可以使用与 Go 相同的 <code>Go get</code> 下载命令，且被添加到 pkgset中。</p><p>例如，使用以下代码获得 <code>gorilla/mux</code> 包，然后检查 pkgset：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[chris@marvin]$ go get github.com/gorilla/mux</span><br><span class="line">[chris@marvin]$ tree</span><br><span class="line">[chris@marvin introToGvm ]$ tree</span><br><span class="line">.</span><br><span class="line">├── overlay</span><br><span class="line">│   ├── bin</span><br><span class="line">│   └── lib</span><br><span class="line">│       └── pkgconfig</span><br><span class="line">├── pkg</span><br><span class="line">│   └── linux_amd64</span><br><span class="line">│       └── github.com</span><br><span class="line">│           └── gorilla</span><br><span class="line">│               └── mux.a</span><br><span class="line">src/</span><br><span class="line">└── github.com</span><br><span class="line">    └── gorilla</span><br><span class="line">        └── mux</span><br><span class="line">            ├── AUTHORS</span><br><span class="line">            ├── bench_test.go</span><br><span class="line">            ├── context.go</span><br><span class="line">            ├── context_test.go</span><br><span class="line">            ├── doc.go</span><br><span class="line">            ├── example_authentication_middleware_test.go</span><br><span class="line">            ├── example_cors_method_middleware_test.go</span><br><span class="line">            ├── example_route_test.go</span><br><span class="line">            ├── go.mod</span><br><span class="line">            ├── LICENSE</span><br><span class="line">            ├── middleware.go</span><br><span class="line">            ├── middleware_test.go</span><br><span class="line">            ├── mux.go</span><br><span class="line">            ├── mux_test.go</span><br><span class="line">            ├── old_test.go</span><br><span class="line">            ├── README.md</span><br><span class="line">            ├── regexp.go</span><br><span class="line">            ├── route.go</span><br><span class="line">            └── test_helpers.go</span><br></pre></td></tr></table></figure><p>如您所见，<code>gorilla/mux</code> 按照预期添加到了 pkgset  的 <code>$GOPATH</code> 目录，现在它可以与使用该 pkgset 的项目一起使用了。</p><h2 id="GVM-让-Go-管理变得轻而易举"><a href="#GVM-让-Go-管理变得轻而易举" class="headerlink" title="GVM 让 Go 管理变得轻而易举"></a>GVM 让 Go 管理变得轻而易举</h2><p>GVM 是以一种直观的、非侵入性的方式来管理 Go 版本和包的。它可以单独使用，也可以使用 GVM 的 Go 版本管理功能与其他 Go 模块管理技术结合使用。通过 Go 版本和包依赖关系隔离项目使开发更容易，并减少了管理版本冲突的复杂性，而GVM使这变得轻而易举。</p><blockquote><p>本文译自 <a href="https://opensource.com/article/19/10/go-introduction-gvm" target="_blank" rel="noopener">opensource</a></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>php原理之对象的属性</title>
      <link href="//blog/php%E5%8E%9F%E7%90%86%E4%B9%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7.html"/>
      <url>//blog/php%E5%8E%9F%E7%90%86%E4%B9%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7.html</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>之前用easyWechat时获取的用户信息是protected的对象,使用了<code>\0*\0</code>来获取到受保护的对象中的数据,最近在学习php底层的知识,本文讲述了为什么<code>\0*\0</code>能获取到受保护的数据</p></blockquote><h2 id="对象的结构"><a href="#对象的结构" class="headerlink" title="对象的结构"></a>对象的结构</h2><p>在php中,一个对象,还是以一个zval做为载体的</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="class"><span class="keyword">union</span> <span class="title">_zvalue_value</span> &#123;</span></span><br><span class="line">    long lval;</span><br><span class="line">    double dval;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        char *val;</span><br><span class="line">        int len;</span><br><span class="line">    &#125; str;</span><br><span class="line">    HashTable *ht;</span><br><span class="line">    zend_object_value obj;</span><br><span class="line">&#125; zvalue_value;</span><br></pre></td></tr></table></figure><a id="more"></a><p>如果,一个zval是对象,那么zvalue_value中的对象,就指向一个zend_object_value的实例。一个zend_object_value包含两个成员,一个是标识符(整形序号),表明了当前对象存储在全局对象列表的位置,另外还有一个zend_object_handlers指针,指向当前对象所属类的handlers(标准操作集合).<br>真正的对象实体,zend_object中,保存了如下的关键信息入口:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="selector-class">.ce</span>,zend_class_entry 类入口</span><br><span class="line"><span class="number">2</span><span class="selector-class">.properties</span>,hashTable普通属性集</span><br></pre></td></tr></table></figure><h2 id="对象的属性"><a href="#对象的属性" class="headerlink" title="对象的属性"></a>对象的属性</h2><p>如上所述,普通属性是一个hashTable,在PHP5以后,引入了访问权限控制,而访问权限属性,是通过属性名进行区分的(为此Zend引入了zend_mangle_property_name)</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>public 属性名</span><br><span class="line"><span class="number">2.</span>private \<span class="number">0</span>类名\<span class="number">0</span>属性名</span><br><span class="line"><span class="number">3.</span>protected \<span class="number">0</span>*\<span class="number">0</span>属性名</span><br></pre></td></tr></table></figure><p>PHP通过这种方式,实现了对属性访问权限的标识,所以我们如果想要访问对象的私有/保护属性可以:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> $_name1 = <span class="string">"private"</span>;</span><br><span class="line">    <span class="keyword">protected</span> $_name2 = <span class="string">"protected"</span>;</span><br><span class="line">&#125;</span><br><span class="line">$test = <span class="keyword">new</span> Test();</span><br><span class="line">$arr = (<span class="keyword">array</span>)$test;</span><br><span class="line">var_dump($arr[<span class="string">"\0Test\0_name1"</span>]);</span><br><span class="line">var_dump($arr[<span class="string">"\0*\0_name2"</span>]);</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">string(<span class="number">7</span>) <span class="string">"private"</span></span><br><span class="line">string(<span class="number">9</span>) <span class="string">"protected"</span></span><br></pre></td></tr></table></figure><p><code>参考自鸟哥博客</code><a href="http://www.laruence.com" target="_blank" rel="noopener">http://www.laruence.com</a></p>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决mac command not found</title>
      <link href="//blog/%E8%A7%A3%E5%86%B3mac%20command%20not%20found.html"/>
      <url>//blog/%E8%A7%A3%E5%86%B3mac%20command%20not%20found.html</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>最近在配置mac的环境变量后,系统的所有命令都失效了,提示mac command not found,在此记录解决方法</p></blockquote><h2 id="1-先让命令暂时可用"><a href="#1-先让命令暂时可用" class="headerlink" title="1.先让命令暂时可用"></a>1.先让命令暂时可用</h2><p>命令如下</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=<span class="regexp">/usr/bin</span><span class="symbol">:/usr/sbin</span><span class="symbol">:/bin</span><span class="symbol">:/sbin</span><span class="symbol">:/usr/X11R6/bin</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>命令执行后不要关闭终端或者cd /usr/bin 下执行vi命令否则会再次失效  </p><h2 id="2-检查bash-profile文件"><a href="#2-检查bash-profile文件" class="headerlink" title="2.检查bash_profile文件"></a>2.检查bash_profile文件</h2><p>很有可能是你的PATH 环境变量设置错误，比如 <code>$PATH</code>漏了，我这里的错误是添加环境变量的时候没有使用<code>&quot;&quot;</code>双引号引起来，还有<code>=</code>等号后面有空格，不知道等号后面有空格会不会影响，加上双引号，去掉空格就可以了<code>PATH=$PATH:$PATH1</code> 可以写成这样的格式：<code>export PATH=/usr/local/msyql/bin:$PATH</code></p><h2 id="3-保存bash-profile文件"><a href="#3-保存bash-profile文件" class="headerlink" title="3.保存bash_profile文件"></a>3.保存bash_profile文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> mac </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
