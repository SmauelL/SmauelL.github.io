<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico?v=7.3.0"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=7.3.0"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=7.3.0"><link rel="mask-icon" href="/images/favicon.ico?v=7.3.0" color="#222"><link rel="stylesheet" href="/css/main.css?v=7.3.0"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"7.3.0",exturl:!1,sidebar:{position:"left",display:"always",offset:10,onmobile:!1},copycode:{enable:!0,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,algolia:{appID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!0,preload:!0},path:"search.xml",motion:{enable:!1,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},translation:{copy_button:"复制",copy_success:"复制成功",copy_failure:"复制失败"}}</script><meta name="description" content="前言对于 Golang 来说，实现一个简单的 http server 非常容易，只需要短短几行代码。同时有了协程的加持，Go 实现的 http server 能够取得非常优秀的性能。这篇文章将会对 go 标准库 net/http 实现 http 服务的原理进行较为深入的探究，以此来学习了解网络编程的常见范式以及设计思路。"><meta name="keywords" content="SmauelL"><meta property="og:type" content="article"><meta property="og:title" content="server"><meta property="og:url" content="http://www.liaojiaxing.com/blog/深入理解golang之http server.html"><meta property="og:site_name" content="SmauelL的博客"><meta property="og:description" content="前言对于 Golang 来说，实现一个简单的 http server 非常容易，只需要短短几行代码。同时有了协程的加持，Go 实现的 http server 能够取得非常优秀的性能。这篇文章将会对 go 标准库 net/http 实现 http 服务的原理进行较为深入的探究，以此来学习了解网络编程的常见范式以及设计思路。"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://cdn.learnku.com/uploads/images/202001/13/36517/54v6mIm1nI.webp!large"><meta property="og:updated_time" content="2020-01-13T03:02:25.778Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="server"><meta name="twitter:description" content="前言对于 Golang 来说，实现一个简单的 http server 非常容易，只需要短短几行代码。同时有了协程的加持，Go 实现的 http server 能够取得非常优秀的性能。这篇文章将会对 go 标准库 net/http 实现 http 服务的原理进行较为深入的探究，以此来学习了解网络编程的常见范式以及设计思路。"><meta name="twitter:image" content="https://cdn.learnku.com/uploads/images/202001/13/36517/54v6mIm1nI.webp!large"><link rel="canonical" href="http://www.liaojiaxing.com/blog/深入理解golang之http server"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,isPage:!1,isArchive:!1}</script><title>server | SmauelL的博客</title><meta name="generator" content="Hexo 3.9.0"><script pjax>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?2ef0e2689610421ccdf1221c7c4e6d6f";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN"><div class="container"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">SmauelL的博客</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">刻意练习,不断提高</p></div><div class="site-nav-toggle"> <button aria-label="切换导航栏"><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul></nav><div class="site-search"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-wrapper"> <input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="搜索..." spellcheck="false" type="text" id="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"></div></div><div class="search-pop-overlay"></div></div></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content page-post-detail"><div id="posts" class="posts-expand"><article class="post" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://www.liaojiaxing.com/blog/深入理解golang之http server.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="SmauelL"><meta itemprop="description" content="SmauelL"><meta itemprop="image" content="/images/blog_avatar.jpeg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="SmauelL的博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">server</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-01-13 11:01:00 / 修改时间：11:02:25" itemprop="dateCreated datePublished" datetime="2020-01-13T11:01:00+08:00">2020-01-13</time></span><span id="/blog/深入理解golang之http server.html" class="post-meta-item leancloud_visitors" data-flag-title="server" title="阅读次数"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span class="leancloud-visitors-count"></span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i></span> <span class="post-meta-item-text">评论数：</span><a title="评论数" href="/blog/深入理解golang之http server.html#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/blog/深入理解golang之http server.html" itemprop="commentCount"></span></a></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>对于 Golang 来说，实现一个简单的 <code>http server</code> 非常容易，只需要短短几行代码。同时有了协程的加持，Go 实现的 <code>http server</code> 能够取得非常优秀的性能。这篇文章将会对 go 标准库 <code>net/http</code> 实现 http 服务的原理进行较为深入的探究，以此来学习了解网络编程的常见范式以及设计思路。</p><a id="more"></a><h3 id="HTTP服务"><a href="#HTTP服务" class="headerlink" title="HTTP服务"></a>HTTP服务</h3><p>基于 HTTP 构建的网络应用包括两个端，即客户端( <code>Client</code> )和服务端( <code>Server</code> )。两个端的交互行为包括从客户端发出 <code>request</code>、服务端接受 <code>request</code> 进行处理并返回 <code>response</code> 以及客户端处理 <code>response</code>。所以http服务器的工作就在于如何接受来自客户端的 <code>request</code>，并向客户端返回 <code>response</code>。</p><p>典型的 http 服务端的处理流程可以用下图表示：</p><p><img src="https://cdn.learnku.com/uploads/images/202001/13/36517/54v6mIm1nI.webp!large" alt></p><p>服务器在接收到请求时，首先会进入路由( <code>router</code> )，这是一个 <code>Multiplexer</code>，路由的工作在于为这个 <code>request</code> 找到对应的处理器( <code>handler</code> )，处理器对 <code>request</code> 进行处理，并构建 <code>response</code>。Golang 实现的 <code>http server</code> 同样遵循这样的处理流程。</p><p>我们先看看 Golang 如何实现一个简单的 <code>http server</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indexHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	fmt.Fprintf(w, <span class="string">"hello world"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">"/"</span>, indexHandler)</span><br><span class="line">	http.ListenAndServe(<span class="string">":8000"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码之后，在浏览器中打开 <code>localhost:8000</code> 就可以看到 <code>hello world</code>。这段代码先利用 <code>http.HandleFunc</code> 在根路由 <code>/</code> 上注册了一个 <code>indexHandler</code>, 然后利用 <code>http.ListenAndServe</code> 开启监听。当有请求过来时，则根据路由执行对应的 <code>handler</code> 函数。</p><p>我们再来看一下另外一种常见的 <code>http server</code> 实现方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> indexHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">	content <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ih *indexHandler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	fmt.Fprintf(w, ih.content)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.Handle(<span class="string">"/"</span>, &amp;indexHandler&#123;content: <span class="string">"hello world!"</span>&#125;)</span><br><span class="line">	http.ListenAndServe(<span class="string">":8001"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go实现的<code>http</code>服务步骤非常简单，首先注册路由，然后创建服务并开启监听即可。下文我们将从注册路由、开启服务、处理请求这几个步骤了解Golang如何实现<code>http</code>服务。</p><h3 id="注册路由"><a href="#注册路由" class="headerlink" title="注册路由"></a>注册路由</h3><p><code>http.HandleFunc</code> 和 <code>http.Handle</code> 都是用于注册路由，可以发现两者的区别在于第二个参数，前者是一个具有 <code>func(w http.ResponseWriter, r *http.Requests)</code> 签名的函数，而后者是一个结构体，该结构体实现了 <code>func(w http.ResponseWriter, r *http.Requests)</code> 签名的方法。<br><code>http.HandleFunc</code> 和 <code>http.Handle</code> 的源码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">	DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HandleFunc registers the handler function for the given pattern.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"http: nil handler"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	mux.Handle(pattern, HandlerFunc(handler))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handle</span><span class="params">(pattern <span class="keyword">string</span>, handler Handler)</span></span> &#123;</span><br><span class="line">	DefaultServeMux.Handle(pattern, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这两个函数最终都由 <code>DefaultServeMux</code> 调用 <code>Handle</code> 方法来完成路由的注册。<br>这里我们遇到两种类型的对象：<code>ServeMux</code> 和 <code>Handler</code>，我们先说 <code>Handler</code>。</p><h5 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h5><p><code>Handler</code> 是一个接口：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Handler<span class="built_in"> interface </span>&#123;</span><br><span class="line">	ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Handler</code> 接口中声明了名为 <code>ServeHTTP</code> 的函数签名，也就是说任何结构只要实现了这个 <code>ServeHTTP</code> 方法，那么这个结构体就是一个 <code>Handler</code> 对象。其实 go 的 <code>http</code> 服务都是基于 <code>Handler</code> 进行处理，而 <code>Handler</code> 对象的 <code>ServeHTTP</code> 方法也正是用以处理 <code>request</code> 并构建 <code>response</code> 的核心逻辑所在。</p><p>回到上面的 <code>HandleFunc</code> 函数，注意一下这行代码：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mux.Handle(pattern, HandlerFunc(<span class="keyword">handler</span>))</span><br></pre></td></tr></table></figure><p>可能有人认为 <code>HandlerFunc</code> 是一个函数，包装了传入的 <code>handler</code> 函数，返回了一个 <code>Handler</code> 对象。然而这里 <code>HandlerFunc</code> 实际上是将 <code>handler</code> 函数做了一个<strong>类型转换</strong>，看一下 <code>HandlerFunc</code> 的定义：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br><span class="line"></span><br><span class="line">// ServeHTTP calls f(w, r).</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f HandlerFunc)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span> &#123;</span></span><br><span class="line">	f(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>HandlerFunc</code> 是一个类型，只不过表示的是一个具有 <code>func(ResponseWriter, *Request)</code> 签名的函数类型，并且这种类型实现了 <code>ServeHTTP</code> 方法（在 <code>ServeHTTP</code> 方法中又调用了自身），也就是说这个类型的函数其实就是一个 <code>Handler</code> 类型的对象。利用这种类型转换，我们可以将一个 <code>handler</code> 函数转换为一个<br><code>Handler</code> 对象，而不需要定义一个结构体，再让这个结构实现 <code>ServeHTTP</code> 方法。读者可以体会一下这种技巧。</p><h5 id="ServeMux"><a href="#ServeMux" class="headerlink" title="ServeMux"></a>ServeMux</h5><p>Golang中的路由（即 <code>Multiplexer</code> ）基于 <code>ServeMux</code> 结构，先看一下 <code>ServeMux</code> 的定义：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> ServeMux <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu    sync.RWMutex</span><br><span class="line">	m     map[<span class="keyword">string</span>]muxEntry</span><br><span class="line">	es    []muxEntry <span class="comment">// slice of entries sorted from longest to shortest.</span></span><br><span class="line">	hosts <span class="keyword">bool</span>       <span class="comment">// whether any patterns contain hostnames</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> muxEntry <span class="keyword">struct</span> &#123;</span><br><span class="line">	h       http.Handler</span><br><span class="line">	pattern <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里重点关注 <code>ServeMux</code> 中的字段 <code>m</code>，这是一个 <code>map</code>，<code>key</code> 是路由表达式，<code>value</code> 是一个 <code>muxEntry</code> 结构， <code>muxEntry</code> 结构体存储了对应的路由表达式和 <code>handler</code>。</p><p>值得注意的是，<code>ServeMux</code> 也实现了 <code>ServeHTTP</code> 方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> r.RequestURI == <span class="string">"*"</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> r.ProtoAtLeast(<span class="number">1</span>, <span class="number">1</span>) &#123;</span><br><span class="line">			w.Header().Set(<span class="string">"Connection"</span>, <span class="string">"close"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		w.WriteHeader(StatusBadRequest)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	h, _ := mux.Handler(r)</span><br><span class="line">	h.ServeHTTP(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说 <code>ServeMux</code> 结构体也是 <code>Handler</code> 对象，只不过 <code>ServeMux</code> 的 <code>ServeHTTP</code> 方法不是用来处理具体的 <code>request</code> 和构建 <code>response</code>，而是用来确定路由注册的 <code>handler</code>。</p><h5 id="注册路由-1"><a href="#注册路由-1" class="headerlink" title="注册路由"></a>注册路由</h5><p>搞明白<code>Handler</code> 和 <code>ServeMux</code> 之后，我们再回到之前的代码：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DefaultServeMux.Handle(pattern, <span class="keyword">handler</span>)</span><br></pre></td></tr></table></figure><p>这里的 <code>DefaultServeMux</code> 表示一个默认的 <code>Multiplexer</code>，当我们没有创建自定义的 <code>Multiplexer</code>，则会自动使用一个默认的 <code>Multiplexer</code>。</p><p>然后再看一下 <code>ServeMux</code> 的 <code>Handle</code> 方法具体做了什么：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">Handle</span><span class="params">(patternstring, handlerHandler)</span></span> &#123;</span><br><span class="line">	mux.mu.Lock()</span><br><span class="line">	defermux.mu.Unlock()</span><br><span class="line">	<span class="keyword">if</span> pattern == <span class="string">""</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"http:invalidpattern"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"http:nilhandler"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> _, exist := mux.m[pattern]; exist &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"http: multiple registrations for "</span> + pattern)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> mux.m == <span class="literal">nil</span> &#123;</span><br><span class="line">		mux.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//利用当前的路由和handler创建muxEntry对象</span></span><br><span class="line">	e := muxEntry&#123;h: handler, pattern: pattern&#125;</span><br><span class="line">	<span class="comment">//向ServeMux的map[string]muxEntry增加新的路由匹配规则</span></span><br><span class="line">	mux.m[pattern] = e</span><br><span class="line">	<span class="comment">//如果路由表达式以'/'结尾，则将对应的muxEntry对象加入到[]muxEntry中，按照路由表达式长度排序</span></span><br><span class="line">	<span class="keyword">if</span> pattern[<span class="built_in">len</span>(pattern)<span class="number">-1</span>] == <span class="string">'/'</span> &#123;</span><br><span class="line">		mux.es = appendSorted(mux.es, e)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> pattern[<span class="number">0</span>] != <span class="string">'/'</span> &#123;</span><br><span class="line">		mux.hosts = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Handle</code> 方法主要做了两件事情：一个就是向 <code>ServeMux</code> 的 <code>map[string]muxEntry</code> 增加给定的路由匹配规则；然后如果路由表达式以 <code>&#39;/&#39;</code> 结尾，则将对应的 <code>muxEntry</code> 对象加入到 <code>[]muxEntry</code> 中，按照路由表达式长度排序。前者很好理解，但后者可能不太容易看出来有什么作用，这个问题后面再作分析。</p><h5 id="自定义-ServeMux"><a href="#自定义-ServeMux" class="headerlink" title="自定义 ServeMux"></a>自定义 ServeMux</h5><p>我们也可以创建自定义的 <code>ServeMux</code> 取代默认的 <code>DefaultServeMux</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	"fmt"</span><br><span class="line">	"net/http"</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func indexHandler(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">	fmt.Fprintf(w, "hello  world")</span><br><span class="line">&#125;</span><br><span class="line">func htmlHandler(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">	w.Header().Set("Content-Type", "text/html")</span><br><span class="line">	html := `<span class="meta">&lt;!doctype  html&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="name">META</span>  <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span>  <span class="attr">content</span>=<span class="string">"text/html"</span>  <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span>    </span><br><span class="line">	<span class="tag">&lt;<span class="name">html</span>  <span class="attr">lang</span>=<span class="string">"zhCN"</span>&gt;</span>  </span><br><span class="line">			<span class="tag">&lt;<span class="name">head</span>&gt;</span>   </span><br><span class="line">					<span class="tag">&lt;<span class="name">title</span>&gt;</span>Golang<span class="tag">&lt;/<span class="name">title</span>&gt;</span>  </span><br><span class="line">					<span class="tag">&lt;<span class="name">meta</span>  <span class="attr">name</span>=<span class="string">"viewport"</span>  <span class="attr">content</span>=<span class="string">"width=device-width,  initial-scale=1.0,  maximum-scale=1.0,  user-scalable=0;"</span>  /&gt;</span>   </span><br><span class="line">			<span class="tag">&lt;/<span class="name">head</span>&gt;</span>     </span><br><span class="line">			<span class="tag">&lt;<span class="name">body</span>&gt;</span>        </span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span>  <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span>Welcome!<span class="tag">&lt;/<span class="name">div</span>&gt;</span>       </span><br><span class="line">			<span class="tag">&lt;/<span class="name">body</span>&gt;</span>   </span><br><span class="line">	<span class="tag">&lt;/<span class="name">html</span>&gt;</span>`</span><br><span class="line">	fmt.Fprintf(w, html)</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">	mux := http.NewServeMux()</span><br><span class="line">	mux.Handle("/", http.HandlerFunc(indexHandler))</span><br><span class="line">	mux.HandleFunc("/welcome", htmlHandler)</span><br><span class="line">	http.ListenAndServe(":8001", mux)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>NewServeMux()</code> 可以创建一个 <code>ServeMux</code> 实例，之前提到 <code>ServeMux</code> 也实现了 <code>ServeHTTP</code> 方法，因此 <code>mux</code> 也是一个 <code>Handler</code> 对象。对于 <code>ListenAndServe()</code> 方法，如果传入的 <code>handler</code> 参数是自定义 <code>ServeMux</code> 实例 <code>mux</code>，那么 <code>Server</code> 实例接收到的路由对象将不再是 <code>DefaultServeMux</code> 而是 <code>mux</code>。</p><h3 id="开启服务"><a href="#开启服务" class="headerlink" title="开启服务"></a>开启服务</h3><p>首先从 <code>http.ListenAndServe</code> 这个方法开始：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(addr <span class="keyword">string</span>, handler Handler)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	server := &amp;Server&#123;Addr: addr, Handler: handler&#125;</span><br><span class="line">	<span class="keyword">return</span> server.ListenAndServe()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">ListenAndServe</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> srv.shuttingDown() &#123;</span><br><span class="line">		<span class="keyword">return</span> ErrServerClosed</span><br><span class="line">	&#125;</span><br><span class="line">	addr := srv.Addr</span><br><span class="line">	<span class="keyword">if</span> addr == <span class="string">""</span> &#123;</span><br><span class="line">		addr = <span class="string">":http"</span></span><br><span class="line">	&#125;</span><br><span class="line">	ln, err := net.Listen(<span class="string">"tcp"</span>, addr)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> srv.Serve(tcpKeepAliveListener&#123;ln.(*net.TCPListener)&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先创建了一个 <code>Server</code> 对象，传入了地址和 <code>handler</code> 参数，然后调用 <code>Server</code> 对象 <code>ListenAndServe()</code> 方法。</p><p>看一下 <code>Server</code> 这个结构体，<code>Server</code> 结构体中字段比较多，可以先大致了解一下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">type Server struct &#123;</span><br><span class="line">	Addr              string  <span class="comment">// TCP address to listen on, ":http" if empty</span></span><br><span class="line">	Handler           Handler <span class="comment">// handler to invoke, http.DefaultServeMux if nil</span></span><br><span class="line">	TLSConfig         *tls.Config</span><br><span class="line">	ReadTimeout       <span class="selector-tag">time</span>.Duration</span><br><span class="line">	ReadHeaderTimeout <span class="selector-tag">time</span>.Duration</span><br><span class="line">	WriteTimeout      <span class="selector-tag">time</span>.Duration</span><br><span class="line">	IdleTimeout       <span class="selector-tag">time</span>.Duration</span><br><span class="line">	MaxHeaderBytes    int</span><br><span class="line">	TLSNextProto      map[string]func(*Server, *tls<span class="selector-class">.Conn</span>, Handler)</span><br><span class="line">	ConnState         func(net<span class="selector-class">.Conn</span>, ConnState)</span><br><span class="line">	ErrorLog          *log.Logger</span><br><span class="line">	disableKeepAlives int32     <span class="comment">// accessed atomically.</span></span><br><span class="line">	inShutdown        int32     <span class="comment">// accessed atomically (non-zero means we're in Shutdown)</span></span><br><span class="line">	nextProtoOnce     sync<span class="selector-class">.Once</span> <span class="comment">// guards setupHTTP2_* init</span></span><br><span class="line">	nextProtoErr      error     <span class="comment">// result of http2.ConfigureServer if used</span></span><br><span class="line">	mu                sync.Mutex</span><br><span class="line">	listeners         map[*net.Listener]struct&#123;&#125;</span><br><span class="line">	activeConn        map[*conn]struct&#123;&#125;</span><br><span class="line">	doneChan          chan struct&#123;&#125;</span><br><span class="line">	onShutdown        []func()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>Server</code> 的 <code>ListenAndServe</code> 方法中，会初始化监听地址 <code>Addr</code>，同时调用 <code>Listen</code> 方法设置监听。最后将监听的 TCP 对象传入 <code>Serve</code> 方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">Serve</span><span class="params">(l net.Listener)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	baseCtx := context.Background() <span class="comment">// base is always background, per Issue 16220</span></span><br><span class="line">	ctx := context.WithValue(baseCtx, ServerContextKey, srv)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		rw, e := l.Accept() <span class="comment">// 等待新的连接建立</span></span><br><span class="line">		...</span><br><span class="line">		c := srv.newConn(rw)</span><br><span class="line">		c.setState(c.rwc, StateNew) <span class="comment">// before Serve can return</span></span><br><span class="line">		<span class="keyword">go</span> c.serve(ctx)             <span class="comment">// 创建新的协程处理请求</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里隐去了一些细节，以便了解 <code>Serve</code> 方法的主要逻辑。首先创建一个上下文对象，然后调用 <code>Listener</code> 的 <code>Accept()</code> 等待新的连接建立；一旦有新的连接建立，则调用 <code>Server</code> 的 <code>newConn()</code> 创建新的连接对象，并将连接的状态标志为 <code>StateNew</code>，然后开启一个新的 <code>goroutine</code> 处理连接请求。</p><h3 id="处理连接"><a href="#处理连接" class="headerlink" title="处理连接"></a>处理连接</h3><p>我们继续探索 <code>conn</code> 的 <code>serve()</code> 方法，这个方法同样很长，我们同样只看关键逻辑。坚持一下，马上就要看见大海了。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(<span class="built_in">c</span> *conn)</span></span> serve(ctx context.<span class="type">Context</span>) &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		w, err := <span class="built_in">c</span>.readRequest(ctx)</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">c</span>.r.remain != <span class="built_in">c</span>.server.initialReadLimitSize() &#123;</span><br><span class="line">			<span class="comment">// If we read any bytes off the wire, we're active.</span></span><br><span class="line">			<span class="built_in">c</span>.setState(<span class="built_in">c</span>.rwc, <span class="type">StateActive</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// HTTP cannot have multiple simultaneous active requests.[*]</span></span><br><span class="line">		<span class="comment">// Until the server replies to this request, it can't read another,</span></span><br><span class="line">		<span class="comment">// so we might as well run the handler in this goroutine.</span></span><br><span class="line">		<span class="comment">// [*] Not strictly true: HTTP pipelining. We could let them all process</span></span><br><span class="line">		<span class="comment">// in parallel even if their responses need to be serialized.</span></span><br><span class="line">		<span class="comment">// But we're not going to implement HTTP pipelining because it</span></span><br><span class="line">		<span class="comment">// was never deployed in the wild and the answer is HTTP/2.</span></span><br><span class="line">		serverHandler&#123;<span class="built_in">c</span>.server&#125;.<span class="type">ServeHTTP</span>(w, w.req)</span><br><span class="line">		w.cancelCtx()</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">c</span>.hijacked() &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		w.finishRequest()</span><br><span class="line">		<span class="keyword">if</span> !w.shouldReuseConnection() &#123;</span><br><span class="line">			<span class="keyword">if</span> w.requestBodyLimitHit || w.closedRequestBodyEarly() &#123;</span><br><span class="line">				<span class="built_in">c</span>.closeWriteAndWait()</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">c</span>.setState(<span class="built_in">c</span>.rwc, <span class="type">StateIdle</span>)</span><br><span class="line">		<span class="built_in">c</span>.curReq.<span class="type">Store</span>((*response)(<span class="literal">nil</span>))</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个连接建立之后，该连接中所有的请求都将在这个协程中进行处理，直到连接被关闭。在 <code>serve()</code> 方法中会循环调用<code>readRequest()</code> 方法读取下一个请求进行处理，其中最关键的逻辑就是一行代码：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">serverHandler</span>&#123;c.server&#125;.ServeHTTP(w, w<span class="meta">.req</span>)</span><br></pre></td></tr></table></figure><p>进一步解释 <code>serverHandler</code>：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">type serverHandler struct &#123;</span><br><span class="line">	srv *Server</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request) &#123;</span><br><span class="line">	handler := sh.srv.Handler</span><br><span class="line">	if handler == nil &#123;</span><br><span class="line">		handler = DefaultServeMux</span><br><span class="line">	&#125;</span><br><span class="line">	if req.RequestURI == <span class="string">"*"</span> &amp;&amp; req.Method == <span class="string">"<span class="keyword">OPTIONS</span>"</span> &#123;</span><br><span class="line">		handler = globalOptionsHandler&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	handler.ServeHTTP(rw, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>serverHandler</code> 的 <code>ServeHTTP()</code> 方法里的 <code>sh.srv.Handler</code> 其实就是我们最初在 <code>http.ListenAndServe()</code> 中传入的 <code>Handler</code> 对象，也就是我们自定义的 <code>ServeMux</code> 对象。如果该 <code>Handler</code> 对象为 <code>nil</code>，则会使用默认的 <code>DefaultServeMux</code>。最后调用 <code>ServeMux</code> 的 <code>ServeHTTP()</code> 方法匹配当前路由对应的 <code>handler</code> 方法。</p><p>后面的逻辑就相对简单清晰了，主要在于调用 <code>ServeMux</code> 的 <code>match</code> 方法匹配到对应的已注册的路由表达式和 <code>handler</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServeHTTP dispatches the request to the handler whose</span></span><br><span class="line"><span class="comment">// pattern most closely matches the request URL.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> r.RequestURI == <span class="string">"*"</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> r.ProtoAtLeast(<span class="number">1</span>, <span class="number">1</span>) &#123;</span><br><span class="line">			w.Header().Set(<span class="string">"Connection"</span>, <span class="string">"close"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		w.WriteHeader(StatusBadRequest)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	h, _ := mux.Handler(r)</span><br><span class="line">	h.ServeHTTP(w, r)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">handler</span><span class="params">(host, path <span class="keyword">string</span>)</span> <span class="params">(h Handler, pattern <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	mux.mu.RLock()</span><br><span class="line">	<span class="keyword">defer</span> mux.mu.RUnlock()</span><br><span class="line">	<span class="comment">// Host-specific pattern takes precedence over generic ones</span></span><br><span class="line">	<span class="keyword">if</span> mux.hosts &#123;</span><br><span class="line">		h, pattern = mux.match(host + path)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">		h, pattern = mux.match(path)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">		h, pattern = NotFoundHandler(), <span class="string">""</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find a handler on a handler map given a path string.</span></span><br><span class="line"><span class="comment">// Most-specific (longest) pattern wins.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">match</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="params">(h Handler, pattern <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Check for exact match first.</span></span><br><span class="line">	v, ok := mux.m[path]</span><br><span class="line">	<span class="keyword">if</span> ok &#123;</span><br><span class="line">		<span class="keyword">return</span> v.h, v.pattern</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Check for longest valid match.  mux.es contains all patterns</span></span><br><span class="line">	<span class="comment">// that end in / sorted from longest to shortest.</span></span><br><span class="line">	<span class="keyword">for</span> _, e := <span class="keyword">range</span> mux.es &#123;</span><br><span class="line">		<span class="keyword">if</span> strings.HasPrefix(path, e.pattern) &#123;</span><br><span class="line">			<span class="keyword">return</span> e.h, e.pattern</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="string">""</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>match</code> 方法里我们看到之前提到的 mux 的 <code>m</code> 字段(类型为 <code>map[string]muxEntry</code> )和 <code>es</code> (类型为 <code>[]muxEntry</code>)。这个方法里首先会利用进行精确匹配，在 <code>map[string]muxEntry</code> 中查找是否有对应的路由规则存在；如果没有匹配的路由规则，则会利用 <code>es</code> 进行近似匹配。</p><p>之前提到在注册路由时会把以 <code>&#39;/&#39;</code> 结尾的路由（可称为<strong>节点路由</strong>）加入到 <code>es</code> 字段的 <code>[]muxEntry</code> 中。对于类似 <code>/path1/path2/path3</code> 这样的路由，如果不能找到精确匹配的路由规则，那么则会去匹配和当前路由最接近的已注册的父节点路由，所以如果路由 <code>/path1/path2/</code> 已注册，那么该路由会被匹配，否则继续匹配下一个父节点路由，直到根路由 <code>/</code>。</p><p>由于 <code>[]muxEntry</code> 中的 <code>muxEntry</code> 按照路由表达式从长到短排序，所以进行近似匹配时匹配到的节点路由一定是已注册父节点路由中最相近的。</p><p>至此，Go 实现的 <code>http server</code> 的大致原理介绍完毕！</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Golang 通过 <code>ServeMux</code> 定义了一个多路器来管理路由，并通过 <code>Handler</code> 接口定义了路由处理函数的统一规范，即 <code>Handler</code> 都须实现 <code>ServeHTTP</code> 方法；同时 <code>Handler</code> 接口提供了强大的扩展性，方便开发者通过 <code>Handler</code> 接口实现各种中间件。相信大家阅读下来也能感受到 <code>Handler</code> 对象在 <code>server</code> 服务的实现中真的无处不在。理解了 <code>server</code> 实现的基本原理，大家就可以在此基础上阅读一些第三方的 <code>http server</code> 框架，以及编写特定功能的中间件。</p><p>以上。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://studygolang.com/pkgdoc" target="_blank" rel="noopener">【Golang标准库文档–net/http】</a></p><blockquote><p>转载自<a href="https://juejin.im/post/5dd11baff265da0c0c1fe813#heading-2" target="_blank" rel="noopener">掘金</a></p></blockquote></div><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>本文作者：</strong> SmauelL</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="http://www.liaojiaxing.com/blog/深入理解golang之http server.html" title="server">http://www.liaojiaxing.com/blog/深入理解golang之http server.html</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/blog/一文详解微服务架构.html" rel="next" title="一文详解微服务架构"><i class="fa fa-chevron-left"></i> 一文详解微服务架构</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"></div></div></footer></div></article></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav"><li class="sidebar-nav-toc" data-target="post-toc-wrap"> 文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP服务"><span class="nav-number">2.</span> <span class="nav-text">HTTP服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#注册路由"><span class="nav-number">3.</span> <span class="nav-text">注册路由</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Handler"><span class="nav-number">3.0.1.</span> <span class="nav-text">Handler</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ServeMux"><span class="nav-number">3.0.2.</span> <span class="nav-text">ServeMux</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#注册路由-1"><span class="nav-number">3.0.3.</span> <span class="nav-text">注册路由</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#自定义-ServeMux"><span class="nav-number">3.0.4.</span> <span class="nav-text">自定义 ServeMux</span></a></li></ol></li></ol><li class="nav-item nav-level-3"><a class="nav-link" href="#开启服务"><span class="nav-number">4.</span> <span class="nav-text">开启服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理连接"><span class="nav-number">5.</span> <span class="nav-text">处理连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">6.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考资料"><span class="nav-number">7.</span> <span class="nav-text">参考资料</span></a></li></div></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="/images/blog_avatar.jpeg" alt="SmauelL"><p class="site-author-name" itemprop="name">SmauelL</p><div class="site-description motion-element" itemprop="description">SmauelL</div></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">5</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">2</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">2</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/SmauelL" title="GitHub &rarr; https://github.com/SmauelL" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i> GitHub</a></span></div><div class="cc-license motion-element" itemprop="license"> <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2020</span><span class="with-love" id="animate"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">SmauelL</span><br><span id="sitetime"></span></div><script language="javascript">function siteTime(){window.setTimeout("siteTime()",1e3);var e=36e5,t=24*e,o=new Date,i=o.getFullYear(),a=o.getMonth()+1,n=o.getDate(),r=o.getHours(),l=o.getMinutes(),s=o.getSeconds(),M=Date.UTC(2019,8,21,15,0,0),g=Date.UTC(i,a,n,r,l,s)-M,m=Math.floor(g/31536e6),T=Math.floor(g/t-365*m),f=Math.floor((g-(365*m+T)*t)/e),h=Math.floor((g-(365*m+T)*t-f*e)/6e4),u=Math.floor((g-(365*m+T)*t-f*e-6e4*h)/1e3);document.getElementById("sitetime").innerHTML="本站已运行"+T+" 天 "+f+" 小时 "+h+" 分钟 "+u+" 秒"}siteTime()</script><div class="busuanzi-count"><script pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item-icon"><i class="fa fa-user"></i></span> <span class="site-uv" title="总访客量"><span>本站总访客量</span><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="site-pv" title="总访问量"><span>本站总访问量</span><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div><script src="/lib/jquery/index.js?v=3.4.1"></script><script src="/lib/pjax/pjax.min.js?v=0.2.8"></script><script src="/js/utils.js?v=7.3.0"></script><script src="/js/schemes/pisces.js?v=7.3.0"></script><script src="/js/next-boot.js?v=7.3.0"></script><script pjax>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script src="/js/local-search.js?v=7.3.0"></script><div id="pjax"><script src="/js/post-details.js?v=7.3.0"></script><script>
NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'xM4mgRfj1W9xpn9lfoklgmOz-gzGzoHsz',
    appKey: 'gmkKu5PM9RVn9azCN4dvVuPw',
    placeholder: '既然来了,那就留下点什么吧...',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: true,
    lang: '' || 'zh-cn',
    path: location.pathname
  });
},window.Valine);
</script></div><script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '#pjax'
  ],
  analytics: false,
  cacheBust: false,
  scrollTo: !CONFIG.bookmark.enable
});
window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    $(element).parent().append($(element).remove());
  });
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script></body></html>